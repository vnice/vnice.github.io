{"meta":{"title":"Tanwei的个人技术博客","subtitle":"仰望大神不如退而求索","description":"暂时没有好描述自己的。。。","author":"Tanwei","url":"http://blog.vnicers.com"},"pages":[{"title":"","date":"2017-08-04T07:57:31.000Z","updated":"2017-08-04T07:57:31.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.vnicers.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-04T07:57:31.000Z","updated":"2017-08-04T07:57:31.000Z","comments":false,"path":"financial/index.html","permalink":"http://blog.vnicers.com/financial/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-04T08:29:35.000Z","updated":"2017-08-04T08:29:35.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.vnicers.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"后端程序员应该会的前端技能","slug":"后端程序员应该会的前端技能","date":"2017-08-09T16:00:00.000Z","updated":"2017-08-15T14:20:40.000Z","comments":true,"path":"2017/08/10/后端程序员应该会的前端技能/","link":"","permalink":"http://blog.vnicers.com/2017/08/10/后端程序员应该会的前端技能/","excerpt":"","text":"后端开发人员应该掌握哪些前端技能这里说的后端开发人员应该是一个很广泛的概念，不是特指某些中间件的开发人员，专门研究某一个领域，而且大多数公司的后端开发也还没有达到研究某一块领域特别专业的程度，一般的后端开发或多或少是需要接触前端的一些东西的。比如我刚毕业的时候找的第一份工作是Java Web 开发程序员，所以需要一些Web的开发经验。比如那时JSP的开发，富客服端的开发。都需要开发人员具有前端的相关知识，一般来说就是基础的html知识，少量的css知识和必备的javascript知识 富客户端框架我觉得只要是产品面向用户的开发人员，JavaScript语言是必须学会的。而且按照现在前端的发展来看JavaScript语言起到的作用也越来越大。之前我的第一份工作是做企业后台程序开发的，当时我们组里面没有前端开发，甚至那个时候还没有前端这个职业，随着html5，webapp的的发展近两年才逐渐火起来了。当时后端程序员的工作既需要开发后台业务，前端的界面也需要开发。但是后端开发人员系统的学习html，css和javascript是非常耗时的一件事。所以当时就使用网上的开源组件，一些富客户端开发技术，比如ExtJs。使用ExtJs开发前端页面，后端开发人员只需要掌握JavaScript。就能开发出页面。不需要html，不需要css。所以ExtJs当时也是非常的流行。 上图是当时总公司开发处来的产品，虽然现在看起来很丑，但是在当时大部分的传统企业还是xp时代和ie6,ie8的时代。ExtJs简直是神器，公司用ExtJs开发出了一套完整的开发框架而且还开源。 ExtJs 的问题当时的ExtJs开发出来的客户端应用是可以跨浏览器，但是对开发人员的要不低，需要熟悉JavaScript。使用面向对象的js开发处可维护的富客户端应用不是一件简单的事。尤其是可维护这点，之前只要是新招来的开发人员如果没有ExtJs的开发经验，他们两个星期之类很难做出一个像样增删改的页面，更别说可维护性了，代码简直惨不忍睹。所以ExtJs对开发人员的要求很高，不像以jQuery作为底层的一些框架EasyUI。而且ExtJs开发它的代码量非常大，ExtJs的API也非常多，开发出来的产品js文件也很大，所以只能用于内部的一些业务系统。 使用BootStrap 和Jquery对于当时ExtJs的问题，项目组开始考虑不再使用ExtJs开发后续的系统，旧的系统也需要慢慢的改造过来。BootStrap现在已经非常的火，尤其是它的响应式设计。使用一套代码，既能在pc端上使用，也能在mobile web上使用.后续的系统全部就打算用bootstrap。由于网上已经存在非常多的BootStrap模板项目，当时我就研究了一个模板，里面所有的控件其实都是别人东拼西凑找来的。H+UI 界面风格 当时看这套UI比较适合后台管理框架，后来就用这套UI完完整整的开发处了一整个系统，从开发的过程中，开发人员需要熟练的使用jQuery这个杀手锏。有了它什么都不用担心。然后按照bootstrap的样式可以做出比较好看的UI。同时当时为了使前端JavaScript代码维护更方便引入了AMD模块化加载RequireJs,给开发人员培训了一下。主要是为了后期的可维护性，因为之前也在这上面吃过不少亏。维护烂代码是一件很痛苦的事情。到这里后端开发人员就无法避免的要接触一些前端的知识，毕竟不是每个公司都能有这个人力来分工明确，前后端分离开发。这个担子必须由我们后端人员来担这。刚开始也很反感做后端为什么需要接触前端一些东西，后来也渐渐看开了，毕竟多学一些东西，是为了更好的开发出产品。 React和Angular以及Vue在使用BootStrap模板框架遇到的一些问题，比如所有的控件五花八门，一个系统需要各种各样的控件，例如我们某个系统使用的插件配置 这才是其中的一部分，后续又加入了很多。使用这么多插件带来了一些问题就是很难以维护，多个插件之间可能还有兼容性问题。插件本身功能有bug。随着前端工程化的出现，前端框架就出现了三足鼎立的场景 分别是React,Angular,Vue 之前分别研究过这三个框架。根据我们组的前端知识储备情况，选择了React相比较其他两个框架的原因，主要是React的jsx的使用非常时候后台开发人员，他们也并不反感。但是Angular的使用，尤其是Angular的几个版本互不兼容，以及TypeScript的学习，让组内的同事感到有点吃力。Vue也相对于其他两个框架更简洁方便。当时有考虑，但是它的项目背景大家也知道，在国外Vue相比Angular和React也没啥出名度。这里不是黑Vue。 前两天看到知乎上的Anglar 布道师大漠穷秋满嘴跑火车黑了Vue，导致他被Google fire掉，技术没有对错，攻击别人确实是不应该。 React的使用感想引入了React，不是为了技术而技术，而是基于React的开发过程，促使大家一切都是以组件的思考模式，这的确让业务也变的更加清晰，开发效率提升，维护成本降低React 只是一个前端框架，它并不包含任何的UI,之前在github上找到蚂蚁金服开源的一个框架ant-design可以看看它的官网。不仅提供了一整套的UI解决方案。同时给出的一些设计原则正好解决了我们系统在开发过程中的一些痛点，以前我们数据中心组一直没有UI/UE相关的规范 设计原则 所以后面完全使用该框架开发新的系统。 React全家桶使用React不仅需要UI，还需要一些三方框架来搭配，比如路由。这里给出一个图，这个图以及解释了React全家桶的使用。我们的系统中也是完全使用该全家桶构建。 一张图读懂React 技术栈 查看原图","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://blog.vnicers.com/tags/其它/"}]},{"title":"阿里云服务器的使用","slug":"阿里云服务器使用","date":"2017-08-06T16:00:00.000Z","updated":"2017-08-13T07:57:57.000Z","comments":true,"path":"2017/08/07/阿里云服务器使用/","link":"","permalink":"http://blog.vnicers.com/2017/08/07/阿里云服务器使用/","excerpt":"","text":"VPS之前一直使用的digitalocean ,国外的一个云主机提供商，但是离我最近的节点是新加坡节点，有时候延迟慢的受不了，所以换了阿里云使用。用过一段时间后，发现效果很不错，最近的香港节点的使用和只用真机的感觉差不多。而且第一次使用还有优惠每月30块，或者每年330.因为之前还有DigitalOcean还在用，所以直接就买了一个月的，现在到期了，续费发现价格涨了好多一月要110，很是后悔之前没有买一年的。不过我新注册了一个账号还是可以参加活动的 阿里云的活动地址 强力推荐 如果你觉得阿里云不好的话，之前写过一篇文章讲的是在DigitalOcean VPS上搭建科学上网的，大家可以参考参考,文章地址 使用DigitalOcean搭建科学上网服务 同样你也可以在阿里云里面购买海外主机，比如香港的最合适，前几天阿里的售后打电话过来，我特意问了关于在阿里云海外主机上搭建翻墙相关的软件，他们是什么态度，- -，售后说现在这些阿里内部没有限制，完全看国家政策。国家现在只是限制了VPN，还没有限制私人VPS。所以在阿里云上搭建翻墙软件，暂时来说还是可以用的。 最近我买的一个月的阿里云主机已经到期了，所以用新账号买了一个一年。 阿里云的使用阿里云的使用很简单，主要看你用来做什么，它提供的控制台功能非常多。我主要使用的是它的云服务器ECS，在上面搭建科学上网，下载一下新东西。 端口的开放 这里要说一下，默认你申请的云主机只开发了22端口和3389端口，如果你自己要在主机里面搭建一些服务的话，除了在系统中的防火墙开放端口以外，还需要在控制台的安全组规则中开发。 它在主页你登陆的时候也有下面的提示 &gt; 安全组未设置任何自定义放行规则，会导致无法访问实例端口，若需访问请添加安全组规则放行对应的端口。 这里大家根据自己的需要开放端口。注意服务器本身也需要开放防火墙端口，例如CentOS7 之前的文章有说，参考文章 Centos7防火墙端口开放 域名的申请 如果你还没有属于自己的域名，可以在阿里云的万网中申请注册域名。很简单。这里说一下注意点，申请的域名一定要实名认证，否则域名将无法解析，如下图 网站备案 如果你的服务器想长期经营则一定要备案，还有如果是个人，但是服务器在海外或者香港这些地方的话不用备案，也没有办法备案，不影响使用。但是域名一定要实名认证。 账号间的镜像迁移 如果你有多个阿里云账号，想将其中的一台迁移到另一个账号中的话，可以参考一下下面我的做法。因为之前用账号买了一个月的30块钱的服务器要到期了，续费的话又很贵，后来新注册了一个账号参加上面的活动够来的330一年的云主机，但是以前一个月的主机上安装了很多东西，又不想重复的弄，所以你需要迁移你的旧的主机到新的主机上面来。 源机器创建自定义镜像 在镜像列表中共享镜像 选择共享给哪个账号 注意这里填写的是你另外一个新账号的UID,这个id在你的账号资料中有的如下图 在新账号中查看共享的镜像 上面共享成功后，这里可以查看到共享的镜像 在新账号中更换系统盘 先停止新账号中的实例，然后更换系统盘 选择批量更改 选择共享镜像 这里选择旧账号共享给你的镜像快照，重新设置密码，或者创建后设置也可以。然后确定即可 系统盘更换成功 在更换前需要手机验证码验证 等待系统重新启动 验证机器上的软件和服务器都是否完整。 域名的迁移 之前在旧的账号上绑定的域名也需要迁移到新的账号上然后设置新的ip地址 重新设置域名解析 将子域名，邮箱域名和主域名全部替换成新的服务器ip地址。 等待DNS 缓存刷新完后。验证域名是否已经指向新的服务器ip地址、 迁移工作完成 停掉旧的账号上面的云服务器。开始使用新账号上的服务器。验证各项服务功能是否正常。","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://blog.vnicers.com/tags/其它/"}]},{"title":"Dubbo重新维护","slug":"Dubbo重新维护","date":"2017-08-04T16:00:00.000Z","updated":"2017-08-29T04:59:46.000Z","comments":true,"path":"2017/08/05/Dubbo重新维护/","link":"","permalink":"http://blog.vnicers.com/2017/08/05/Dubbo重新维护/","excerpt":"","text":"今天从群里得到消息说Dubbo又重新维护了，然后去官网看了一下，确实是得到官方重新维护了，但是还不了解最新的规划放向 看了下github上的issue 面临的问题还是有很多的，但是应付一般的企业需求应该是足够了。之前公司里面用过阿里的烂尾项目，踩了很多坑。所以现在还是慎重选择国内的开源框架。 Dubbo的一些坑在application节点设置logger使用slf4j之后，还是报没有找到log4j的警告在dubbo启动之前设置 System.setProperty(&quot;dubbo.application.logger&quot;,&quot;slf4j&quot;); 使用Dubbo注解@Service 和Spring注解 @Transactional冲突的问题，同样存在于和其他自定义使用AOP代理过得对象有冲突原因:Dubbo早期 使用Spring2,如果自己排除了Spring低版本，使用高版本的Spring。其代理的生成方式有变，早期使用JDK动态代理，现在默认是使用CGLib字节码生成方式而Dubbo对于字节码生成方式没有做考虑，所以存在问题 解决方案1： 123456Service service;if (AopUtils.isAopProxy(proxy) )&#123; service =（根据代理对象获得到的cglib或者jdkproxy的原始对象）&#125;else&#123; service = bean.getClass().getAnnotation(Service.class);&#125; 解决方案2：不用注解，使用xml方式更好 2.5.3会间歇性连接超时 问题 参考解决方案 以及修改host文件 分布式事物问题dubbo暂时没有支持分布式事物的功能，考虑之后将dubbox的分布式事物功能合并过来， 可以自己使用Zookeeper自己实现分布式事物 dubbo 管理控制台的问题dubbo的管理控制台是一个阉割版。到处是bug。推荐使用 [dubbokeeper](https://github.com/dubboclub/dubbokeeper) 优雅停机的bugdubbo的原生graceful shutdown是有bug的，仅释放了一些资源但没有尝试等待服务线程结束。官方还在进行修复和优化，另外如果dubbo是同web容器一起启动的话，dubbo和web容器会有一个时间差, 具体可以参考解决方案https://my.oschina.net/u/1398931/blog/790709 提供者的RpcResult的attachment放了值，消费着获取不到必须要从扩展的层次来操作，比如通过做Filter扩展 dubbo提供者线程池满了后不返回报错新版本2.5.4 说是解决了。未验证，参考issue https://github.com/alibaba/dubbo/issues/494 dubbo 提供restful webservice该功能暂时还没排上计划，可以自己使用resteasy 或者spring mvc Dubbo以webservice协议发布接口时不支持最新的CXF可以使用cxf老版本的xfire，或者cxf新版本的3.1.6 客户端与服务端Channel断了，无法自动恢复自己还没有碰到该问题，这是个大问题 - -，详见https://github.com/alibaba/dubbo/issues/458 服务提供者启动暴露服务后，少量请求超时多半是有的服务接口处理耗时较长，在配置里面把对应的超时时间调大一点应该就可以了 dubbo的异步调用传递性问题若cosumer async=true去调 serviceA,确实是异步调用.serviceA并未在xml配置async .那么serviceA调用serviceB会变成async=true异步的,导致返回值为null 在查看了github 的issue之后作者标记在2.5.4.M1 里程碑版本重点在解决这个问题 消费者抛监控异常配置文件打开了dubbo的监控，但是simple-monitor没有运行。 dubbo 默认的序列化方式存在的问题dubbo默认序列化协议是hession，hession对于特殊对象，序列化不行这是他的一大劣势，解决办法： 1、自己转化下思路，比如转化为string类型的 2、不用hession协议，直接使用protobuf协议做序列化协议 所有非dubbo的序列化协议都是不建议在生成上使用的- -非dubbo协议为了调试和测试使用的，使用非Dubbo的协议都存在一个问题，如何进行服务注册与服务发布？以及如何进行负载均衡等？ Spring Cloud能够选择Spring Cloud的话还是选择Spring Cloud吧，指望dubbo能够稳定下来还是遥遥无期","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.vnicers.com/tags/分布式/"}]},{"title":"关于此博客","slug":"关于此博客","date":"2017-07-26T21:51:27.000Z","updated":"2017-08-23T11:28:59.000Z","comments":true,"path":"2017/07/27/关于此博客/","link":"","permalink":"http://blog.vnicers.com/2017/07/27/关于此博客/","excerpt":"","text":"搭建原因之前博客是东写一下，西写一下，到处都有，像什么csdn，segmentfault，简书,什么都有，有的是记一下遇到的问题的解决方案，有的是转载一下别人，后面再也没有关注过，都只是零零散散的记录一些东西。没时间打理，现在终于换到自己搭建的Blog了。后面会花一段时间陆续会把之前的blog转移过来。 博客框架的选择刚开始是想从头到尾一个人写博客框架的，但是后来想想，这也得花大把的精力来维护，所以在网上找了找开源的。从之前关注的一些开发者的博客看到一些界面挺好看的比如纯洁的微笑的博客,上次特意问他本人用的博客框架，用的Yummy-Jekyll的主题，我也折腾了一番，但是看到github上好像有一年作者没有更新了，所以放弃用Yummy-Jekyll了。后来在网上搜索了一下现在流行的应该是Hexo。然后就选择它了。所用的主题是indigo，还是比较钟意material-design风格的。 搭建搭建的步骤这里我就不细说了。上面的github上都有说。主要是先使用node安装hexo，然后配置hexo，配置github，然后下载主题indigo,按照它的配置文档一步步来操作就OK了。这说下我之前碰到的一个坑。因为之前一直用linux系统，然后我这个人呢，基本上什么框架都想用最新的，在安装nodejs的时候用的最新版，然后发布博客始终报错，具体的是因为一个node 的依赖在 node v8里面已经弃用了。然后坑了自己大半天，不过我从来不介意碰到问题。有问题解决掉它，虽然当了回小白鼠，但是问题还是被我解决了。 评论系统评论系统之前选择的是indigo配置中的disqus，但是用过一段时间后发现有时候评论组件不会加载出来，而且登陆评论的账号可能需要翻墙才可以，后来看到支持了 gitment,一个基于github issue的评论组件，真心佩服开发这个组件个哥们，很好的利用了github 的功能，又不用担心自己运营的问题。所以推荐大家都用gitment评论组件。一个字赞效果如下： Gitment 注意，这里自己每发表一篇博客记得先自己初始化评论组件，不然没有初始化的文章别人是不能评论的。 文章中的图片渲染刚开始写的文章使用的本地图片，将图片的相对路径放到hexo主题文件夹下，然后生成发布之后就可以，但是在自己写过程中是看不到当前图片的，在网上找到了新浪微博图床使用很简单，需要chrome 应用商店下载 新浪微博图床，然后将图片扔到插件上去就可以了，如下 新浪微博图床 上传记录 同时支持http和https的，直接生产markdown图片链接。而且不用担心文件丢失，是不是很方便呢 遇到的坑因为hexo写博客都是使用的makedown ，然后我直接在WebStrorm中用了一个markdown插件来写，但是好几次发现，自己写的东西渲染不成功，感觉什么都没写一样，有一次还碰到关了软件，几个文件的内容都不见了。连WebStrorm的文件的LocalHistpry历史记录都没有，jetbrains的东西有时候也都不靠谱啊。害我重新写,然后我重新换了一个markdown插件就再也没有出现过这鬼问题了。","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://blog.vnicers.com/tags/其它/"}]},{"title":"Linux 集群软件安装","slug":"Linux 集群软件安装","date":"2017-07-04T16:00:00.000Z","updated":"2017-08-09T15:28:37.000Z","comments":true,"path":"2017/07/05/Linux 集群软件安装/","link":"","permalink":"http://blog.vnicers.com/2017/07/05/Linux 集群软件安装/","excerpt":"","text":"需求 之前公司需要将某个系统部署切换到Linux 上部署多台，当时是两台Oracle Linux ，软件的安装让我来负责，刚开始就是一台一台的弄，感觉有点傻，还好是两台，如果是集群，那不得累死人。所以趁休息这个机会在家捣鼓一下，如果使用一台机器同时控制多台机器部署软件。 下面我直接使用MAC 机器下的5台CentOS7 来测试，内存还算给力。这5台机器全部是Centos7 mini 版安装。使用第5台机器来控制剩下的4台同时安装软件。 寻找工具在经过一番Google和知乎上搜索知乎，别人推荐使用pssh 工具来安装。pssh 意思是 parallel ssh program 一个python编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的，类似pdsh使用方法 。为方便操作，使用前请在各个服务器上配置好密钥认证访问。项目地址: parallel-ssh (代码托管在google code 需要翻墙) 下载pssh1234wget http://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gztar zxvf pssh-2.3.1.tar.gzcd pssh-2.3.1/python setup.py install python 在centos mini版本中已经存在。所以不需要安装python 首先保证这5台机器网络是通的。在操作的机器上新建立一个host.txt文件里面存放其他需要安装软件的机器配置如下。 host.txt 执行命令测试，所有命令如下-h 执行命令的远程主机列表,文件内容格式[user@]host[:port] 如 test@172.16.10.10:229 -H 执行命令主机，主机格式 user@ip:port -l 远程机器的用户名 -p 一次最大允许多少连接 -P 执行时输出执行信息 -o 输出内容重定向到一个文件 -e 执行错误重定向到一个文件 -t 设置命令执行超时时间 -A 提示输入密码并且把密码传递给ssh(如果私钥也有密码也用这个参数) -O 设置ssh一些选项 -x 设置ssh额外的一些参数，可以多个，不同参数间空格分开 -X 同-x,但是只能设置一个参数 -i 显示标准输出和标准错误在每台host执行完毕后 1pssh -P -A -i -h host.txt -e error uptime 执行上面的命令会报错 Exited with error code 255 这是因为pssh的一个bug没有传递接收秘钥的信息给命令执行者，所以后面根本没办法执行命令。你可以先手动ssh单独一台机器接受ssh fingerprint 再看看效果，如下图 我先手动ssh 连接到了10.211.55.10这台机器，接受了fingerprint yes,然后执行了命令，其他没接受的全部抱错，但是这台机uptime命令执行成功，如果机器数量较小的话，可以先手动ssh 连接一下。 如果机器数量众多，可以安装keychina工具参考这篇文章 然后我这边没有试验，因为CentOS 7环境中的keychina工具在rpm中无法直接下载。需要手动build一个，太麻烦了。 下图显示在四台机器中执行w命令 测试安装软件发现一个很扯淡的问题。凡是遇到需要手动接收yes/no的地方全部处理失败 不过同时执行一些普通命令还是有效的。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"使用DigitalOcean搭建科学上网服务","slug":"使用DigitalOcean搭建科学上网服务","date":"2017-07-01T16:00:00.000Z","updated":"2017-08-09T05:10:45.000Z","comments":true,"path":"2017/07/02/使用DigitalOcean搭建科学上网服务/","link":"","permalink":"http://blog.vnicers.com/2017/07/02/使用DigitalOcean搭建科学上网服务/","excerpt":"","text":"注册 首先在DigitalOcean官网使用邮箱注册账号 绑定信息在注册成功后需要绑定信用卡或者Paypal支付账号。这里只是绑定一个信息，并不是需要真正支付，后面每个月会有订单发给你支付。，这里推荐大家使用Paypal，没有可以先注册一个，因为信用卡可能是直接扣美金，如果你的信用卡不支持的话扣款会失败。 创建VPS 创建VPS 这里创建vps就是DigitalOcean中所说的创建一个水滴 选择服务器和配置这里大家根据自己的情况，熟悉哪种操作系统，或者使用的内存。我这里选择的CentOS和最便宜的配置，对于当做SS服务器足够了，然后选择的是新加坡节点，之前测试过因为这个地方离自己最近，延迟相对来说小一点。选择好后直接create 选择服务器和配置 创建中 设置账号和密码创建完成后使用提供的console ssh登录 设置管理员账号和密码，新的密码会发送到你注册的邮箱中，是很长的一串随机数 重置密码 登陆服务器 登录完成后会提示你修改密码。先输入刚刚邮件发送给你的随机密码，然后输入自己想设置的密码，设置完成后，vps就可以用啦。 登录服务器重置密码 搭建科学上网服务下面开始搭建shadowsock 服务器，这里直接别人写好的shadowsock-go一键安装脚本,可以参考，也有其他安装方式。具体步骤就直接安装https://teddysun.com/392.html 上面来了 SS服务器搭建完成 默认按照上面开启的ss server 只有一个账号可以用，就是8989端口。其实可以配置多个账号，可以参考上面的说明，这里注意一下开多个账号，你的端口也需要开通，例如Centos 7 需要开通 下面的8989 9001 9002 9003 9004 端口。具体根据你选择的操作系统来操作。 SS 开通多个账号 多个账号 下载客户端客户端的使用 在shadowsocks github仓库里面有各种客户端，大家可以按照说明使用","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://blog.vnicers.com/tags/其它/"}]},{"title":"Centos7防火墙开放端口","slug":"Centos7 防火墙开放端口","date":"2017-06-04T16:00:00.000Z","updated":"2017-08-09T04:46:22.000Z","comments":true,"path":"2017/06/05/Centos7 防火墙开放端口/","link":"","permalink":"http://blog.vnicers.com/2017/06/05/Centos7 防火墙开放端口/","excerpt":"","text":"CentOS升级到7之后，发现无法使用iptables控制Linuxs的端口，google之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口： 开启端口 firewall-cmd –zone=public –add-port=80/tcp –permanent 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 重启防火墙 firewall-cmd –reload","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"Java知识点总结","slug":"Java知识点总结","date":"2017-03-19T16:00:00.000Z","updated":"2017-08-23T11:28:59.000Z","comments":true,"path":"2017/03/20/Java知识点总结/","link":"","permalink":"http://blog.vnicers.com/2017/03/20/Java知识点总结/","excerpt":"","text":"JVM JVM 中加载Class的原理和机制 Class的加载到主要分5个阶段 1. 加载阶段 主要由类加载器来完成 Bootstrap ClassLoader 负责加载jre中的lib/rt.jar 同时可以指定JVM参数 -Xbootclasspath Extension ClassLoader 负责加载JDK/lib/ext/*.jar 扩展包下面的jar App ClassLoader 负责加载ClassPath下的jar Custom ClassLoader 自定义的类加载器 这些加载器使用双亲委派模式加载。从下往上findClass，然后从上往下loadClass。直到抛出ClassNotFoundException 加载完成后将获取class的二进制流，类信息，静态变量，字节码常量放到方法区，然后再内存中生成Class 对象 2. 验证阶段 首先确保class文件中的字节流中包含的信息符合虚拟机规范，是安全的 然后验证文件格式，元数据，字节码和符号引用 3. 准备阶段 为类的静态变量设置默认初始值。 4. 解析阶段 将虚拟机常量池中的符号引用转换为直接引用。 5. 初始化阶段 给static字段赋予用户指定的值，静态代码块的执行 JVM 的垃圾回收 采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： - 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 - 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 - 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。 新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象 当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 JVM 内存模型 JVM各种参数的含义 -Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定； -Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值； -XX:PermSize 非堆内存 -XX:MaxPermSize 非堆内存最大值 Xmx 与PermSize的和不可超过JVM可获得的总内存 PermSize不可大于Xmx Tomcat JVM参数设置(包括打印GC 日志) linux修改catalina.sh文件 JAVA_OPTS=”-server -Dfile.encoding=UTF-8 -Xms=512m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=256m -verbose:gc -Xloggc:${CATALINA_HOME}/logs/gc.log`date +%Y-%m-%d-%H-%M` -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -noclassgc” 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？ Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。 多线程 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 线程池子 Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池， 如下所示： - newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 - newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 - newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 - newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 一个新的任务提交到线程池之后，线程池是如何处理的 1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。 2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步 3、线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://blog.vnicers.com/tags/其它/"}]},{"title":"ReactNative开发填坑","slug":"ReactNative开发填坑","date":"2017-02-09T16:00:00.000Z","updated":"2017-08-16T05:04:30.000Z","comments":true,"path":"2017/02/10/ReactNative开发填坑/","link":"","permalink":"http://blog.vnicers.com/2017/02/10/ReactNative开发填坑/","excerpt":"","text":"在使用React-Native开发应用前需要有一些移动端的开发经验，不然遇到的问题够你喝一壶的。而且是Android和IOS两边的问题。 IOS 运行报错 ‘boost/iterator/iterator_adaptor.hpp’ file not found’ 及控制台”:CFBundleIdentifier”, Does Not Exist 原因：boost依赖没有找打，到当前用户目录下的.rncahe目录下查找boost_1_63_0.tar.gz文件，如果存在查看是否能够正常解压如果不能，需要手动到网上下载该包下载地址Boot_1_63_0然后放入.rncache文件夹中。 IOS config.h file not found 根据这个issue 找到解决方法 1$ rm -rf node_modules/ &amp;&amp; yarn cache clean &amp;&amp; yarn install 重新安装依赖项目 最好分别用Android Studio 和Xcode工具能够把两个项目先运行起来。在开发工具中运行成功后，用react-native的命令会简单很多。然后遇到问题解决问题。 android 项目第一次 打开很慢的问题。第一次打开需要下载gradle相关的包。可以去gradle官网先手动下载下来，然后将gradle环境在本机运行好之后再打开android项目。 4 Start Systrace 之后报错 global.nativeTraceBeginSection is not a function 根据官方人员的回答： I’m aware of this issue. We currently don’t have these methods on the C++ bridge since the C++ implementation depends on fbsystrace, which is not open-source. As a workaround, you can revert back to RCTBatchedBridge (ReactLegacy), we’ll try to find a solution for this soon. 暂时还没解决。所以先不要用Systrace。不然报错之后只能重新跑模拟器。","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog.vnicers.com/tags/移动端/"}]},{"title":"分布式事物","slug":"分布式事物","date":"2017-01-07T16:00:00.000Z","updated":"2017-08-17T05:43:08.000Z","comments":true,"path":"2017/01/08/分布式事物/","link":"","permalink":"http://blog.vnicers.com/2017/01/08/分布式事物/","excerpt":"","text":"前提 在分布式数据库中，数据分散在个台不同的机器上，包括机器的宕机，各种网络异常，为了保证事物的可靠性，分布式事物是无法避免的。分布式事物是指事物的参与者，支持事物的服务器，资源服务器，以及事物管理器，分别定位于分布式事物的不同几点上。通常一个分布式事物中会涉及对多个数据源及业务系统的操作 参考之前写过的一篇文章《Spring 多数据源的处理》 场景","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.vnicers.com/tags/分布式/"}]},{"title":"分布式基本理论","slug":"分布式基本理论","date":"2017-01-01T16:00:00.000Z","updated":"2017-08-12T10:04:23.000Z","comments":true,"path":"2017/01/02/分布式基本理论/","link":"","permalink":"http://blog.vnicers.com/2017/01/02/分布式基本理论/","excerpt":"","text":"前提 这段时间开始需要接触分布式相关的东西，改造公司的几个传统集中式项目，又要临时抱佛脚补补基础了。 书籍 从网上只找到国内阿里中间件出版的一本书《从Paxos到ZooKepper分布式一致性原理与实践》 如果习惯了国外的一些动物书，什么权威指南之类的，看这本书封面的画风，很容易让人忽略掉它其中实际的内容 以下是书中的一些概念。 集中式的特点 所谓的集中式系统就是指由一台或多台主计算机组成中心节点, 数据集中存储干这个中 心节点中, 并且整个系统的所有业务单元都集中部署在这个中心节点上, 系统的所有功 能均由其集中处理。 也就是说, 在集中式系统中, 每个终端或客户端机器仅仅负责数据 的录人和输出, 而数据的存储与控制处理完全交由主机来完成。 集中式系统最大的特点就是部署结构简单。 由干集中式系统往往基于底层性能卓越的大 型主机, 因此无须考虑如何对服务进行多个节点的部署, 也就不用考虑多个节点之间的 分布式协作问题。 分布式的特点分布性 分布式系统中的多台计算机都会在空间上随意分布，同时，机器的分布情况也会随时变动。 对等性 分布式系统中的计算机没有主/从之分, 既没有控制整个系统的主机, 也没有被控制的从机, 组成分布式系统的所有计算机节点都是对等的。 副本 (Replica) 是分布 式系统最常见的概念之一, 指的是分布式系统对数据和服务提供的一种冗余方式。 在常见的分布式系统中, 为了对外提供高可用的服务, 我们往往会对数据和服务进行副本处理。 数据副本是指在不同的节点上持久化同一份数据, 当某一个节点上存 储的数据丢失时, 可以从副本上读取到该数据, 这是解决分布式系统数据丢失问题 最为有效的手段。 另一类副本是服务副本, 指多个节点提供同样的服务, 每个节点都有能力接收来自外部的请求并进行相应的处理。 并发性 在一个计算机网络中, 程序运行过程中的并发性操作是非常常见的行为, 例如同一个分布 式系统中的多个节点, 可能会并发地操作一些共享的资源, 诸如数据库或分布式存 储等, 如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最 大的挑战之一。 缺乏全局时钟 一个典型的分布式系统是由一系列在空间上随 意分布的多个进程组成的, 具有明显的分布性, 这些进程之间通过交换消息来进行 相互通信。 因此, 在分布式系统中, 很难定义两个事件究竟谁先谁后, 原因就是因 为分布式系统缺乏一个全局的时钟序列控制。 故障总会发生 组成分布式系统的所有计算机, 都有可能发生任何形式的故障。 一个被大量工程实 践所检验过的黄金定理是: 任何在设计阶段考虑到的异常情况, 一定会在系统实际 运行中发生, 并且, 在系统实际运行过程中还会遇到很多在设计时未能考虑到的异 常故障。 所以, 除非需求指标允许, 在系统设计时不能放过任何异常情况。 分布式环境的各种问题通信异常 从集中式向分布式演变的过程中, 必然引人了网络因素, 而由于网络本身的不可靠性, 因此也引入了额外的问题。 分布式系统需要在各个节点之间进行网络通信, 因此每次网 络通信都会伴随着网络不可用的风险, 网络光纤、 路由器或是 DNS 等硬件设备或是系 统不可用都会导致最终分布式系统无法顺利完成一次网络通信。 另外, 即使分布式系统 各节点之间的网络通信能够正常进行, 其延时也会远大于单机操作。 通常我们认为在现 代计算机体系结构中, 单机内存访问的延时在纳秒数量级 (通常是 10nS 左右), 而正常 的一次网络通信的延迟在 0-1~1mS 左右 (相当于内存访问延时的 l05~l06 倍), 如此巨 大的延时差别, 也会影响消息的收发的过程, 因此消息丢失和消息延迟变得非常普遍。 网络分区 当网络由于发生异常情况, 导致分布式系统中部分节点之间的网络延时不断增大, 最终 导致组成分布式系统的所有节点中, 只有部分节点之间能够迸行正常通信, 而另一些节 点则不能一一我们将这个现象称为网络分区, 就是俗称的 “脑裂”。 当网络分区出现时, 分布式系统会出现局部小集群, 在极端情况下, 这些局部小集群会独立完成原本需要整 个分布式系统才能完成的功能, 包括对数据的事务处理, 这就对分布式一致性提出了非常大的挑战 三态 从上面的介绍中,我们已经了解到了在分布式环境下,网络可能会出现各式各样的问题, 因此分布式系统的每一次请求与响应, 存在特有的“三态”概念, 即成功、失败与超时。 在传统的单机系统中, 应用程序在调用一个函数之后, 能够得到一个非常明确的响应: 成功或失败。 而在分布式系统中, 由干网络是不可靠的, 虽然在绝大部分情况下, 网络 通信也能够接收到成功或失败的响应, 但是当网络出现异常的情况下, 就可能会出现超 时现象, 通常有以下两种情况: 由于网络原因, 该请求 (消息) 并没有被成功地发送到接收方, 而是在发送过程 就发生了消息丢失现象。 该请求 (消息) 成功的被接收方接收后, 并迸行了处理, 但是在将响应反馈给发 送方的过程中, 发生了消息丢失现象。 当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被正确成功处理的。 节点故障节点故障则是分布式环境下另一个比较常见的问题, 指的是组成分布式系统的服务器节点出现的宕机或 “僵死” 现象。 通常根据经验来说, 每个节点都有可能会出现故障, 并且每天都在发生。 分布式系统事物处理的挑战ACID理论 事务 (Transaction) 是由一系列对系统中数据进行访问与更新的操作所组成的一个程序 执行逻辑单元 (Unit), 狭义上的事务特指数据库事务。 一方面, 当多个应用程序并发访 问数据库时, 事务可以在这些应用程序之间提供一个隔离方法, 以防止彼此的操作互相 干扰。 另一方面, 事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法, 同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。事物就有四个特征，分别是原子性(Atomicity)，一致性(Consistency),隔离性(Isolation)和持久性(Durablity) ,简称为事物的ACID特性 原则性 事物的原子性指的是事物必须是一个原子操作的操作序列单元，事物中包含的各项操作在一此执行过程中，只运行出现以下两种状态，全部执行成功，全部不执行。任何一项操作失败都将导致整个事物失败，同时其他已经被执行的操作都将被撤销并且回滚，只有所有的操作全部成功，整个事物才算是成功完成的。 一致性 事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性, 一个事务在执行 之前和执行之后, 数据库都必须处干一致性状态。 也就是说, 事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态, 因此当数据库只包含成功事务提交 的结果时, 就能说数据库处干一致性状态。 而如果数据库系统在运行过程中发生故障, 有些事务尚未完成就被迫中断, 这些未完成的事务对数据库所做的修改有一部分已写人 物理数据库, 这时数据库就处于一种不正确的状态, 或者说是不一致的状态。 隔离性 事务的隔离性是指在井发环境中, 并发的事务是相互隔离的, 一个事务的执行不能被其 他事务干扰。 也就是说, 不同的事务并发操纵相同的数据时, 每个事务都有各自完整的 数据空间, 即一个事务内部的操作及使用的数据对其他并发事务是隔离的, 并发执行的 各个事务之间不能互相干扰。 持久性 事务的持久性也被称为永久性, 是指一个事务一旦提交, 它对数据库中对应数据的状态变更就应该是永久性的。 换句话说, 一旦某个事务成功结束, 那么它对数据库所做的更 新就必须被永久保存下来一即便发生系统崩溃或机器宕机等故障, 只要数据库能够重新启动, 那么一定能够将其恢复到事务成功结束时的状态。","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://blog.vnicers.com/tags/分布式/"}]},{"title":"Mac系统中Redis服务的开机启动","slug":"Mac系统中Redis的开机启动","date":"2016-12-11T16:00:00.000Z","updated":"2017-08-10T07:26:32.000Z","comments":true,"path":"2016/12/12/Mac系统中Redis的开机启动/","link":"","permalink":"http://blog.vnicers.com/2016/12/12/Mac系统中Redis的开机启动/","excerpt":"","text":"场景今天在Mac系统上安装了Redis，来做一些程序的测试,但是重新开机后，Redis服务需要手动启动，Linux可以制作启动服务，Mac是否也可以呢 launchd 这里有一篇文章launchd — 你应该了解的 OS X 工具已经说的很清楚，就是我要找的东西 launchd 是苹果公司开发的一个开源的进程管理器，从 Mac OS X 10.4 Tiger 开始，苹果就使用 launchd 来管理系统的守护进程、程序、脚本、定时任务及 OS X 系统环境 使用 首先下载Redis软件，在Make install 之后编写 redis.plist文件，plist文件其实就是一个xml文件。 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;local.autorun.redis&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;!--这里的目录根据自己的情况来创建--&gt; &lt;string&gt;/usr/local/bin/redis-server&lt;/string&gt; &lt;!--这里的目录根据自己的情况来创建--&gt; &lt;string&gt;/usr/local/var/redis/redis.conf&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;tanwei&lt;/string&gt; &lt;key&gt;WorkingDirectory&lt;/key&gt; &lt;string&gt;/usr/local/var&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/usr/local/var/log/redis.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/usr/local/var/log/redis.log&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; 执行命令,plist文件路径根据自己的情况放置。1launchctl load /usr/local/var/redis/redis.plist 重启系统验证Redis是否启动","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.vnicers.com/tags/Mac/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.vnicers.com/tags/Redis/"}]},{"title":"Mac系统常用软件汇总","slug":"Mac 系统常用软件汇总","date":"2016-11-11T16:00:00.000Z","updated":"2017-08-07T13:45:22.000Z","comments":true,"path":"2016/11/12/Mac 系统常用软件汇总/","link":"","permalink":"http://blog.vnicers.com/2016/11/12/Mac 系统常用软件汇总/","excerpt":"","text":"开发者工具 以上都是出自 jetbrain 公司的产品 最新版的，等了好久 说实话用了IDEA，就没怎么用Eclipse了","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.vnicers.com/tags/Mac/"}]},{"title":"权限模型RBAC的使用","slug":"权限模型RBAC的使用","date":"2016-03-11T16:00:00.000Z","updated":"2017-08-14T17:07:18.000Z","comments":true,"path":"2016/03/12/权限模型RBAC的使用/","link":"","permalink":"http://blog.vnicers.com/2016/03/12/权限模型RBAC的使用/","excerpt":"","text":"介绍今天看了一篇文章说的是权限管理RBAC，这个缩略词感觉很高大上，然后细读之后发现就是我之前在项目中所使用的，差不多一样的套路。文章地址 RBAC权限模型——项目实战 整理一下之前负责的项目所使用的权限是如何处理的，具体的RBAC的原理可以看上面这篇文章，我这里简单说一下为什么这样处理。 如何设计权限第一个版本任何一个项目只要涉及到不同的用户使用就会使用权限控制。这里的权限控制就是指一个用户登录系统之后拥有哪些可以使用的功能，哪些可以查看的数据。常见于一个系统之中，不同的角色的人登录系统之后，所看到的菜单是否一样，每个菜单打开之后是否都具有增删查改的权限。 根据以上就出涉及到的几个相关的对象 用户 菜单 操作(按钮,链接,api的调用,数据的查看) 很容易设计出数据库的表结构 第一版，用户和权限之间应该有个中间表弄掉了 这是最简单的设计，用户和菜单多对多 则需要一个中间表，总共四张表搞定。适合小系统。这里解释一下permission表 其中 name表示权限的名称，field表示受控制的元素name,如果type是1,表示控制按钮的操作，前端页面会根据用户的权限是否显示该按钮，同时根据url字段后台也会控制相应的请求是否有权限。如果type为0，则表示后端查询的数据要过滤掉field中所设置的字段。同时前端也要控制表格的列显示。这样前后端都可以控制住权限所有的数据不设置则表示默认有权限。 这样设计的目的能够从前端到后端统一控制 前端草图 添加菜单 添加用户 但是，随着用户后期的添加，每增加一个用户，就需要制定该用户的一系列菜单。简单也带来了相应的问题。所有需要角色表来处理 第二个版本 RBAC0当添加了角色表后，用户和角色多对多，角色和菜单多对多，然后角色和权限多对多，因此会多出三张张中间表 这个版本就已经达到了RBAC0的结构 第三个版本 RBAC1在第二版中，基本上可以满足一般系统的需求，但是当角色过多的时候，会出现一个问题就是，用户赋予多个角色的时候，多个角色之间的权限如何管理。比如同时赋予分管领导的角色和公司领导的角色，那么公司领导的角色是大于分管领导的。拥有的权限完全包括分管领导的权限，这个时候引入了RBAC1, 角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构 这个版本在第二版的基础上改进新增了一张角色分级表，有了这个表，当用户拥有了多个角色之后，安装level的大小分级，处理拥有level越大的权限越大。 在随着系统的扩大之后，可以引入用户组的概念，但是我觉得没有这个必要，角色已经充当了用户组的概念，没必要多弄几张表搞这么复杂。 RBAC2主要是指在授权阶段 RBAC2，它是RBAC的约束模型，RBAC2也是建立的RBAC0的基础之上的，在RBAC0基础上假如了约束的概念，主要引入了静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。 SSD是用户和角色的指派阶段加入的，主要是对用户和角色有如下约束: a、互斥角色：同一个用户在两个互斥角色中只能选择一个 b、基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的 c、先决条件约束：用户想要获得高级角色，首先必须拥有低级角色 DSD是会话和角色之间的约束，可以动态的约束用户拥有的角色，如一个用户可以拥有两个角色，但是运行时只能激活一个角色。 RBAC3 RBAC3，它是RBAC1与RBAC2合集，所以RBAC3是既有角色分层又有约束的一种模型","categories":[],"tags":[{"name":"系统设计","slug":"系统设计","permalink":"http://blog.vnicers.com/tags/系统设计/"}]},{"title":"Apache Shiro 十分钟入门","slug":"Apache Shiro 十分钟入门","date":"2016-02-09T16:00:00.000Z","updated":"2017-08-14T13:29:35.000Z","comments":true,"path":"2016/02/10/Apache Shiro 十分钟入门/","link":"","permalink":"http://blog.vnicers.com/2016/02/10/Apache Shiro 十分钟入门/","excerpt":"","text":"","categories":[{"name":"十分钟入门系列","slug":"十分钟入门系列","permalink":"http://blog.vnicers.com/categories/十分钟入门系列/"}],"tags":[{"name":"开源组件","slug":"开源组件","permalink":"http://blog.vnicers.com/tags/开源组件/"}]},{"title":"FreeMarker十分钟入门","slug":"FreeMarker十分钟入门","date":"2016-01-10T16:00:00.000Z","updated":"2017-08-14T02:22:51.000Z","comments":true,"path":"2016/01/11/FreeMarker十分钟入门/","link":"","permalink":"http://blog.vnicers.com/2016/01/11/FreeMarker十分钟入门/","excerpt":"","text":"在要学习一门新技术直接，一般如何开始入手，达到什么程度叫入门，达到什么程度较学会，达到什么程度叫精通。学习计算机相关的知识，需要我们时刻保持一颗学习的心态。这里打算写一下我的学习过程，叫做《十分钟入门系列》当然十分钟并不能保证你完全入门，但是我们更重要的是学习方法。这里第一篇入门系列是以FreeMarker为开篇，因为最近项目中需要用到，而且以前只是听说，所以要用到才会学习，如果你学了，一时半会用不到，那样也很快会忘记。 如何学习直接Google FreeMarker 关键字，为什么不用百度，这个做开发的都知道，百度上的技术文章烂得跟啥一样的。前排一律，文不对题。不适合技术人员寻找资料，如果没办法Google，再怎么着也得用Bing搜索，百度我觉得只是时候查下身边相关的资料，技术文章Google才是归属。 搜索到的结果是前两条是FreeMarker的官网，第三条是国内的CSDN用户写的博客，说明访问量还是挺多的。但是日期是2012年，肯能比较旧了。所以直接略过，学习一手的东西，直接进第一条官网的就OK 打开FreeMarker官网，直入主题，什么是Apache FreeMarker，看下左侧的目录包括 下载，maven坐标，文档包括手册，java api ，甚至还有中文手册。工具包含编辑器和插件在线模板测试，下面就是组织。看到这些信息，基本是入门到上手没啥问题了。 What is Apache FreeMarker ?读完它的介绍和一副实例图，基本知道FreeMarker是干嘛的了，然后在看完整个介绍后从中获取的信息 FreeMarker是一个模板引擎，这里应该想到它和Velocity是同一类东西。 可以用来生成文本，包括html,邮件，配置文件，源代码等。这里可以知道，一些框架前端现在直接用的FreeMarker来替代jsp，在邮件中实现复杂的html页面将内容动态的替换到指定位置，甚至代码生成器类似的东西也可以用它来做。 使用FreeMarker模板特有的简单的模板语言FTL,你只需要准备好数据，和模板，然后塞到FreeMarker中，他就可以按照你的模板显示出来。 遵循MVC设计模式，非常适合动态网页的显示，将页面和java代码分离，设计师可以不用面对嵌套在页面中的逻辑，可以直接修改页面而不用重新编译代码。这里应该想到它和JSP有什么异同，从下面的分析中寻找答案 不仅可以在web中使用，也可以在非Web环境使用。 从声明中可以看出FreeMarker项目已经交给Apache开源组织管理，现在还是孵化阶段，后面对孵化阶段做了一个解释。 特性一 :条件语句，循环，赋值，字符串，和算数运算以及格式化，宏，以及函数，包含其他模板，转义以及其他。 特性二 :没有任何依赖，各种输出样式，可以从任何地方加载模板。 特性三 :国际化 特性四 :XML处理功能 特性五 :通用数据模型 从上面的特性可以知道，FreeMarker支持的功能应该比JSP和Velocity更强大不少。 Download from Maven在了解完FreeMarker的基本信息之后，可以从Maven中央仓库中下载它的最新版本来玩一下。最新的是2.3版本新建一个Web项目测试 Getting Started 编写模板文件12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt;&lt;p&gt;Our latest product: &lt;a href=\"$&#123;latestProduct.url&#125;\"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;!&lt;/body&gt;&lt;/html&gt; 如果直接访问该文件，模板中的变量会原样输出到界面上。 数据模型介绍数据模型基本结构就是一个对象树，结构和json比较类似。访问方式则和javascript比较类似，子节点的数据类型有字符串，数字，日期/时间 ，布尔值 模板介绍 ${…} ftl变量:会被括号中的表达式实际值替换 &lt;#…&gt; ftl标签:也可以称作指令，不会被输出 &lt;@…&gt; ftl自定义标签 &lt;#–…–&gt; ftl注释，不会被输出 除了以上几个标签其他的任何形式的标签都不会被FreeMarker处理，都会直接输出。 几个基本的指令if elseif else 指令&lt;#if animals.python.price &lt; animals.elephant.price&gt; Pythons are cheaper than elephants today. &lt;#elseif animals.elephant.price &lt; animals.python.price&gt; Elephants are cheaper than pythons today. &lt;#else&gt; Elephants and pythons cost the same today. &lt;/#if&gt; 当表达式为true时，会输出包含的内容 当==左右两边的数据类型不匹配时会报错。 如果表达式是boolean类型，可以使用如下输出 &lt;#if animals.python.protected&gt; Pythons are protected animals! &lt;/#if&gt; list 指令&lt;table border=1&gt; &lt;#list animals as animal&gt; &lt;tr&gt;&lt;td&gt;${animal.name}&lt;td&gt;${animal.price} Euros &lt;/#list&gt; &lt;/table&gt; animals是数据模型中的集合 animal是循环出的单个对象，循环体中可以使用ftl变量 如果list是空的，那么上面的会输出一个&lt;table border=1&gt;&lt;/table&gt;。可以使用将list指令拆成两部分来避免，如下 &lt;#list animals&gt; &lt;table border=1&gt; &lt;#items as animal&gt; &lt;tr&gt;&lt;td&gt;${animal.name}&lt;td&gt;${animal.price} Euros &lt;/#items&gt; &lt;/table&gt; &lt;#list&gt; 如果animals是空，则里面的所有都不会输出。 sep指令&lt;p&gt;Fruits: &lt;#list misc.fruits as fruit&gt;${fruit}&lt;#sep&gt;, &lt;/#list&gt; 可以按照逗号拼接每个item，最后一个则忽略。 include指令 include指令类似于jsp里面的静态include 内置插件user?upper_case 将user变量的值转为大写 animal.name?cap_first 值转成首字母大写 user?length 获取内容长度 animals?size 获取集合大小 在循环 &lt;#list animals as animal&gt; 标签里面: animal?index 获取item的索引从0开始 animal?counter 获取item所在位置从1开始 animal?item_parity 返回基数行或者偶数行字符 &quot;odd&quot; or &quot;even&quot; 带有参数的插件 animal.protected?string(&quot;Y&quot;, &quot;N&quot;) 根据表达式的boolean值 返回字符Y或者N animal?item_cycle(&apos;lightRow&apos;, &apos;darkRow&apos;) 根据基偶行返回知道的字符 fruits?join(&quot;, &quot;): 将集合展开安装指定的字符拼接 user?starts_with(&quot;J&quot;) 判断表达式的值是否是指定的参数开头，返回true或者false 内置插件可以链式调用 空值处理 在Freemarker中一个不存在的变量和该变量值为null是一个意思 为变量指定默认值，当user对象值不存在或为null时，将会用默认值”visitor”代替 1&lt;h1&gt;Welcome $&#123;user!\"visitor\"&#125;!&lt;/h1&gt; 使用表达式??预先判断变量值是否存在然后再渲染 1&lt;#if user??&gt;&lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt;&lt;/#if&gt; 特殊字符处理默认FreeMarker会自动转义所有以$ {…}打印的值，所有的以ftlh和ftlx为扩展名的freemarker模板都会自动关联到HTML和XML输出格式 如果想故意输出特殊字符，则可以使用${value?no_esc} 数据类型标识符字符串，数字，布尔值，日期(日期/时间/日期时间) 容器哈希(对象)，序列(可以使用索引访问)，集合(有限的序列，不能使用索引访问) 方法和函数${avg(3,5)} 获取平均数 结尾FreeMarker的文档应该算是非常的详细了，各种错误示例都有。更多的信息可以直接去官网看文档，小白都可以看懂。","categories":[{"name":"十分钟入门系列","slug":"十分钟入门系列","permalink":"http://blog.vnicers.com/categories/十分钟入门系列/"}],"tags":[{"name":"开源组件","slug":"开源组件","permalink":"http://blog.vnicers.com/tags/开源组件/"}]},{"title":"Mac系统使用常见问题汇总","slug":"Mac系统使用常见问题汇总","date":"2015-11-11T16:00:00.000Z","updated":"2017-08-05T07:41:02.000Z","comments":true,"path":"2015/11/12/Mac系统使用常见问题汇总/","link":"","permalink":"http://blog.vnicers.com/2015/11/12/Mac系统使用常见问题汇总/","excerpt":"","text":"Mac 卸载rEFInd12345678910111213执行检查命令diskutil list | grep EFI | awk '&#123;print $6&#125;'如果显示如下：disk0s1执行卸载命令sudo mkdir /Volumes/efisudo mount -t msdos /dev/disk0s1 /Volumes/efisudo rm -rfP /Volumes/efi/EFI/refindsudo bless --setBoot --mount /重新启动即可","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.vnicers.com/tags/Mac/"}]},{"title":"Redis 注意知识点整理","slug":"Redis 注意知识点整理","date":"2015-05-31T16:00:00.000Z","updated":"2017-08-12T12:12:50.000Z","comments":true,"path":"2015/06/01/Redis 注意知识点整理/","link":"","permalink":"http://blog.vnicers.com/2015/06/01/Redis 注意知识点整理/","excerpt":"","text":"Redis 默认支持16个数据库，可以通过配置参数databases来修改这一数字，客户端与Redis建立链接后会自动选择0号数据库，可以select 命令更换数据库 select 1 Redis 不支持自定义数据库的名字，以编号命名，也不支持为每个数据库设置不同的访问密码。多个数据库之间并不是完全隔离，FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据，Redis中的数据库更像是一种命名空间，而不适合存储不同应用的数据。不同的应用应该使用不同的Redis实例存储。由于Redis非常轻量级，一个空的Redis实例占用内存1mb空间。 keys 命令需要遍历Redis中的所有键，当键的数量较多时会影响性能，不建议在生成环境中使用。 DEL 命令的参数不支持通配符号，可以结合Linux的管道和xargs命令实现删除所有复合规则的键。redis-cli keys &quot;user:*&quot; | xargs redis-cli del 或者redis del redis-cli keys &quot;user:*&quot; 一个字符串类型的键允许存储的最大容量为512MB，字符串类型是其他四中基本类型的基础 Redis 的数据类型同样不支持数据类型嵌套 列表类型的内部是使用双向链表，搭配使用lpush和lpop或者rpop和rpush可以当做栈来使用。如果当成队列则搭配使用lpush和rpop或者rpush和lpop Redis 保证一个事物中的所有命令要么执行，要么不执行，如果在发送exec命令前，客户端断了线，则Redis会清空事物队列。事物中的所有命令都不会执行。而一旦客户端发送了exec命令，所有的命令都会执行。即使客户端断线也没关系。因为Redis中记录了所有要执行的命令 Redis 事物在2.6.5版本之后 如果多个命令中有语法错误，则会忽略所有的命令，正确的命令也不会执行。在2.6.5版本之前会执行正确的命令，如果是运行错误比如使用不同类型的命令操作其他类型。这种错误在实际执行之前Redis是无法发现的。所以出现错误后，其他命令会正常执行 Redis 没有事物回滚的功能，需要自己手动收拾摊子 Redis 使用Watch 命令防止竞态条件 Watch 命令的作用只是当被监控的键值被修改后阻止之后的一个事物执行，而不能保证其他客户端不修改这个键值，所以需要在exec失败后重新执行整个函数","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.vnicers.com/tags/Redis/"}]},{"title":"Linux 使用常见问题汇总","slug":"Linux 使用常见问题汇总","date":"2014-06-04T16:00:00.000Z","updated":"2017-08-05T07:41:02.000Z","comments":true,"path":"2014/06/05/Linux 使用常见问题汇总/","link":"","permalink":"http://blog.vnicers.com/2014/06/05/Linux 使用常见问题汇总/","excerpt":"","text":"后台运行程序将日志输出到指定文件1nohup ./IntelliJIDEALicenseServer_linux_amd64 &gt; ~/var/logs/idealicense.log 2&gt;&amp;1 &amp; apt install Unmet dependencies1sudo apt --fix-broken install CentOS 7 x86_64 新建用户 图形化界面密码正确但是不能登陆的问题12345root@chenghy ~]# vi /etc/pam.d/login#将如下行：session required /lib/security/pam_limits.so#修改成：session required /lib64/security/pam_limits.so 如果没有该行则添加 然后重启，故障排除,貌似这种现象只发现在x86_64服务器中。 CentOS 设置JAVA环境变量之后java和javac 版本不一致的问题​ centOS 7 默认安装后自带了jdk 1.8.0_65 的open jdk不想使用这个版本 然后自己添加了一个jdk 1.8.0_121 版本在/etc/profile 中设置了JAVA_HOME 和CLASSPATH1234export JAVA_HOME=/root/develop/java/jdk-1.8.0_121export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarsource /etc/profile 执行 java -version 显示的任然是open jdk 1.8.0_65执行命令 whereis java显示 java:/usr/bin/java 而不是我们root/develop/下的java备份 /usr/bin/java mv /usr/bin/java /usr/bin/open-jdk.1.8.0_65将我们自己的jdk软链接到/usr/bin/java1ln -s $JAVA_HOME/bin/java /usr/bin/java 验证 java -version javac -version 版本一致OK","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"Linux使用systemd添加系统启动项目","slug":"Linux使用systemd添加系统启动项目","date":"2014-05-23T16:00:00.000Z","updated":"2017-08-05T07:47:19.000Z","comments":true,"path":"2014/05/24/Linux使用systemd添加系统启动项目/","link":"","permalink":"http://blog.vnicers.com/2014/05/24/Linux使用systemd添加系统启动项目/","excerpt":"","text":"12345678910111213141516171819202122232425262728/etc/systemd/system/nexus.serviceThis example is a script that uses systemd to run the repository manager service. Create a file called nexus.service. Add the following contents, then save the file in the /etc/systemd/system/ directory.[Unit]Description=nexus serviceAfter=network.target[Service]Type=forkingExecStart=/opt/nexus/bin/nexus startExecStop=/opt/nexus/bin/nexus stopUser=nexusRestart=on-abort[Install]WantedBy=multi-user.targetActivate the service with the following commands:sudo systemctl daemon-reloadsudo systemctl enable nexus.servicesudo systemctl start nexus.serviceAfter starting the service for any Linux-based operating systems, verify that the service started successfully.tail -f /opt/sonatype-work/nexus3/log/nexus.logcheck statussudo systemctl status nexus","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"Java多线程对象的共享","slug":"Java多线程对象的共享","date":"2014-05-17T16:00:00.000Z","updated":"2017-08-13T06:54:27.000Z","comments":true,"path":"2014/05/18/Java多线程对象的共享/","link":"","permalink":"http://blog.vnicers.com/2014/05/18/Java多线程对象的共享/","excerpt":"","text":"同步代码块和同步方法可以确保以原子的方式执行操作，同时另外一个重要的作用是内存可见性，我们不仅希望防止某个线程正在使用对象的状态，而另一个线程在同时修改这个状态，而且还希望确保一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 可见性通常我们无法确保执行读操作的线程能够适时的看到其他线程写入的值，为了确保多个线程之间对内存的写入操作的可见性必须使用同步机制。 重排序在没有同步的情况下，编译器，处理器，以及运行时等都可能对操作的执行顺序进行一些意想不到的调整，在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论 枷锁与可见性java内置锁可以用于确保某个线程以一种可预见的方式来查看另外一个线程的执行结果，当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证 同步的可见性保证 加锁的含义不仅仅局限于互斥行为，还包括内存的可见性。为了确保所有线程都能得到共享变量的最小值，所有执行读操作或者写操作都必须在同一个锁上同步。 Volatile 变量Java语言提供了一种稍弱的同步机制，即Volatile变量。用来确保将变量的更新操作通知到其他线程。当把变量声明成volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存上的操作一起重排序。volatile变量不会被缓存在寄存器或者其他处理器不可见的地方。因此在读取volatile变量总会返回最新的写入的值。在访问volatile变量不会执行加锁的操作，因此也不会使执行线程阻塞，因此可以将volatile变量看作是一种比synchronized关键字更轻量级的同步机制（synchronized关键字在内存可见性上的作用比volatile变量更强）从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。但是并不建议过度依赖volatile变量的可见性，它通常比使用锁更脆弱，也难以理解。仅当volatile变量能够简化代码的实现以及对同步策略的验证时，才该使用它们。通常volatile变量用作某个操作完成，发生中断或者状态的标志。 ThreadLocalThreadLocal是维持线程封闭性的一种更规范的方法。这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法。这些方法为每个使用该变量的线程都存有一份独立的副本。因此get总是返回由当前执行线程在调用set时设置的最新值 安全的共享对象策略在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改 只读共享 在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，任何线程都不能修改它，共享的只读变量包括不可变对象，和事实不可变对象。 线程安全共享 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象 被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定的锁保护的对象。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"http://blog.vnicers.com/categories/Java并发编程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.vnicers.com/tags/多线程/"}]},{"title":"Java多线程安全性","slug":"Java多线程安全性","date":"2014-05-11T16:00:00.000Z","updated":"2017-08-13T03:48:30.000Z","comments":true,"path":"2014/05/12/Java多线程安全性/","link":"","permalink":"http://blog.vnicers.com/2014/05/12/Java多线程安全性/","excerpt":"","text":"一个对象是否需要线程安全，取决于它是否被多个线程访问，这指的是在程序中访问对象的方式，而不是对象要实现的功能，要使得对象是线程安全的，必须采用同步机制来协同对象可变状态的访问。 当多个线程访问某个状态变量并且其中一个线程执行写入操作的时候，必须采用同步机制来协同这些线程对变量的访问。Java中主要的同步机制是synchronized,它提供了一种独占的枷锁方式。同步这类还包括volatile类型变量，显示锁，以及原子变量 如果多线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。三种解决方式 不在线程间共享该状态变量 将状态变量修改为不可变变量 在访问状态变量时使用同步 线程安全类的定义： 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称为这个类是线程安全的类 无状态的对象一定是线程安全的 竞态条件 当某个计算的正确性取决于多个线程的交替执行时序时了那么就会发生竞态条件、就是一个线程需要判断一个变量的状态，然后根据这个变量的状态来执行某个操作，在执行这个操作之前，这个变量的状态可能会被其他线程修改。 1234567891011@NotThreadSafepublic class LazyInitRace &#123; private ExpensiveObject instance=null; public ExpensiveObject getInstance()&#123; if(instance==null)&#123; instance=new ExpensiveObject(); &#125; return instance; &#125; &#125; 在上面懒汉式单例对象创建的代码中， 在LazyInitRace 中包含了一个竞态条件，它可能会破坏这个类的正确性。假定线程A和线程B 同时执行getInstance 方法。A 看到instance 为空，因此A创建一个新的ExpensiveObject实例。B 同样需要判断instance 是否为空。此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A 需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检查时，instance为空，那么在两次调用getInstance 时可能会得到不同的对象 原子操作要避免竞态条件文件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能修改操作完成之前或之后读取修改状态，而不是在修改过程中 假定有两个操作A和B,如果从执行A的线程来看，当另外一个线程执行B时，要么将B全部执行完，要么全部不执行B,那么A和B的执行对彼此来说都不原子的。原子操作是指，对于访问同一个状态的所有操作包括该操作本身来说，这个操作是一个以原子方式执行的操作。 在实际情况中，应尽可能的使用现有的线程安全对象，来管理类的状态，与非线程安全的对象相比，判断线程安全对象的可能状态以及其状态的转换情况，要更为容易，从而也更容易维护和验证线程的安全性。 要保持状态的一致性，就需要在单个原子操作中更新所有相关状态变量 锁机制java 提供了一种内置的锁机制来支持原子性，同步代码块（Synchronized Block）同步代码块包含两部分：一个是作为锁的对象引用，一个是作为由这个锁保护的代码块，在方法声明中使用synchronized修饰的方法是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是就是方法调用所在的对象。静态的synchronized方法以Class 对象作为锁 每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁或者监视器锁，线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块之前自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出，获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法 Java内置的锁相当于一种互斥的锁，这就意味着最多只有一个线程能够持有这种锁，当线程A尝试获取一个由线程B持有的锁的时候，线程A必须等到或者阻塞，知道线程B释放这个锁，如果B线程永远不释放，那么讲A将永远等下去。 锁的重入机制当某个线程请求一个由其他线程持有的锁的时候，发出请求的线程就会阻塞，然而，由于内置锁是可以重入的，因此如果某个线程视图获得一个已经由它自己持有的锁，那么这个请求就会成功，”重入”意味着获取锁的操作粒度为线程，而不是调用，重入的一种实现方法是，为每个锁关联一个计数值和一个所有者线程，当计数值为0时，这个锁就认为没有被任何线程持有。当线程请求一个未被持有的锁时，JVM记下锁的持有者，并将计数值设置为1.如果同一个线程再次获取这个锁，计数值递增，而当线程退出同步代码块时，计数值会相应的递减。当计数值为0时，这个锁会被释放。 锁的保护状态对于可能被多个线程同时访问的可变状态变量，在访问它时，否需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。每个共享的和可变的变量都应该只由一个锁来保护，从而使开发人员知道是哪一个锁。对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。 锁的性能通常在简单性与性能之间存在着相互制约的因素，当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性 当执行较长的计算或者可能无法快速完成的操作时，例如网络IO,一定不要持有锁。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"http://blog.vnicers.com/categories/Java并发编程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.vnicers.com/tags/多线程/"}]},{"title":"Java 多线程基础知识","slug":"Java多线程基础知识","date":"2014-05-10T16:00:00.000Z","updated":"2017-08-12T05:40:53.000Z","comments":true,"path":"2014/05/11/Java多线程基础知识/","link":"","permalink":"http://blog.vnicers.com/2014/05/11/Java多线程基础知识/","excerpt":"","text":"本系列文章根据《Java并发编程实战》整理 线程安全性问题 在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。1234567public class UnsafeSequence&#123; private int value; public int getNext()&#123; return this.value++; &#125;&#125; UnsafeSequence的问题在于，由于执行时机不对，多个线程在调用getNext时会得到想同的值。value++看上去像单个操作，但是实际上它包含三个独立的操作，读取value，将value加1，并将结果写入value,由于运行是可能将多个线程之间的操作交易执行，因此这连个线程可能同时执行读操作，从而得到相同的值，并同时加1.结果则是在不同线程中返回了相同的结果由于存在指令重排序的肯能，因此实际情况可能会更糟糕。 综上引起线程安全性的几个前提条件 多个线程的交替运行 执行非原子性的操作语句 编译器的指令重排序 由于多个线程要共享相同的内存地址，并且是并发执行，因此他们可能会访问或修改其他线程正在使用的变量，虽然给线程间通信带来了数据共享的便利，但是给多线程执行带来了不可预测的结果，要想多线程的行为可预测，必须对共享变量的操作进行同步。 1234567public class UnsafeSequence&#123; private int value; public synchronized int getNext()&#123; return this.value++; &#125;&#125; 如果没有同步，那么无论是编译器，硬件还是运行时，都可以随意安排操作的执行顺序和时间，例如对寄存器或者处理器中的变量缓存，而这些被缓存的变量对于其他线程来说是暂时不可见的。虽然这些技术可以实现更优的性能，但是给开发人员带来了负担 线程性能问题在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文切换的操作，这种操作带来了极大的开销，保存和恢复上下文，丢失局部性，并且CPU将更多的事件花在调度上而不是线程上面。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存取中的数据无效，以及增加共享内存总线的同步流量。这些因素都将带来额外的性能开销 在使用框架时保证代码的并发安全性框架通过在框架线程中调用应用程序代码并将并发性引入到程序中，在代码中不可避免的访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"http://blog.vnicers.com/categories/Java并发编程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.vnicers.com/tags/多线程/"}]},{"title":"VIM编辑器的基本用法","slug":"VIM编辑器的基本用法","date":"2014-04-05T16:00:00.000Z","updated":"2017-08-05T07:15:56.000Z","comments":true,"path":"2014/04/06/VIM编辑器的基本用法/","link":"","permalink":"http://blog.vnicers.com/2014/04/06/VIM编辑器的基本用法/","excerpt":"","text":"编辑模式使用按下aio任意三个键a 在光标所有字符后插入 A 在光标所在行尾插入 i 在光标所在字符前插入 I 在光标所在行首插入 o 在光标所在下行插入新行 O 在光标所在上行插入新行 光标定位命令设置行号 set nu 取消行号 set nonu 到最后一行 G 到第一行 gg 到任意一行 : n 删除字符删除光标所在字符x或者Backspace 删除光标所在行 dd 删除光标后面的一行D 删除光标后面的所有行dG 复制和粘贴yy 复制一行 dd 剪切一行 p 粘贴到光标下面一行 P 粘贴到光标上面一行 u 撤销上一步的操作搜索指定的字符 /string按n在搜索到的高亮条件中移动 全文替换 :%s /oldStr/newStr/g%s 代表全文 /g 直接替换不询问 /c 替换前询问 保存与退出:w 保存修改 ：wq 保存修改并退出 ：ZZ 保存修改并退出 ：q!直接退出不保存 ：wq! 文件所有者和root 强制修改只读文件并保持 将其他文件内容导入到当前文件中来:r 文件名","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"Linux 常用命令","slug":"Linux 常用命令","date":"2014-04-04T16:00:00.000Z","updated":"2017-08-05T07:15:56.000Z","comments":true,"path":"2014/04/05/Linux 常用命令/","link":"","permalink":"http://blog.vnicers.com/2014/04/05/Linux 常用命令/","excerpt":"","text":"ls显示当前目录下的所有文件 ls [OPTION]... [FILE]... -a --all显示隐藏文件(linux隐藏文件都是.开头) -l --list 显示文件的详细信息(依次为文件权限,引用次数,所有者,所属组,文件大小,最后修改时间，文件名) ls -alh 显示所有文件详细信息，文件大小按照可读的格式显示出来 ls -ld 显示当前目录本身的详细信息 mkdirmake directories 创建目录 mkdir -p [目录名称] 递归创建目录 cdchange directories 切换目录 cd ~ 切换到根目录 cd .. 切换到上级目录 pwdprint working directories 显示当前目录 rmdirremove empty directories 删除空目录 cpcopy 复制目录 cp [源文件...] [目标文件] cp -r 复制目录 cp -rp 复制目录保留属性 mvmove 剪切和改名 mv[源文件或者目录...] [目标文件或者目录] rmremove 删除命令 rm -r -f [文件或者目录] ■ -r 删除目录 ■ -f 强制执行 touch创建空文件 touch [文件名称] cat查看文件 适合查看内容较少的文件 cat -n 查看文件并显示行号 more分页查看文件 more [文件名] 空格或者f 翻页 Enter 换行 q或者Q 退出 less分页查看文件，可以选择往回翻页 在翻页过程中可以 输入/xx 查找相关类容 head查看文件的前几行 head -n 10 查看文件前10行 tail查看文件的末尾几行 tail -n 10 显示文件末尾10行 tail -f 动态显示文件末尾内容 lnlink 创建链接文件 ln -s [源文件] [目标文件] 创建软链接文件 chmod权限管理命令 更改目录或者文件的权限 change the permissions of a file chmod [{ugoa}{+-=}{rwx}] [文件或者目录] chmod -R 777 使用数字表示权限 r=4,w=2,x=1, -R递归修改 chown权限管理命令 chown 更改目录或者文件的所有者 change file ownership chown [用户] [文件或者目录] chgrp权限管理命令 chgrp 更改文件或者目录的所属组 chgrp [组的名称] [文件或者目录] umask权限管理命令 umask 显示新建文件的缺省权限 umask -S 以rwx形式显示文件的缺省权限 find文件搜索命令 find [搜索范围] [匹配条件] find /etc -name init 在 etc 目录下搜索 名称为init的文件 find /etc -name *init* 在 etc 目录下模糊搜索名称带有init的文件 find /etc -name init??? 在 etc 目录下搜索 名称为init后带有三个字符的文件？代表三个字符 -iname 不区分大小写 -size 根据文件大小来查找 +n 204800 代表大于100MB的文件 -n 小于多少的文件 根据数据块的大小来搜索 ■ 一个数据块=512字节=0.5k -user 查找所有者的文件 -amin 访问时间 -cmin 文件属性 -mmin 文件内容 find /etc -mmin -5 表示查找5分钟之类被修改过得文件 -type 按照文件类型查找 f 文件 d 是目录 l 是软链接 -a -o 多个条件搜索是使用and 还是or find /etc/ -name inittab -exec ls -l {} \\; 查找文件并执行命令 find /home -user dev -ok rm {} \\; 查找用户dev下的文件找到后询问删除 find . -inum 31531 -exec rm {} \\; 查找文件节点是31531的文件并删除 locate文件快速搜索命令 在新建文件之后需要updatedb 更新索引 -i不区分大小写 which命令搜索 which rm 查找命令所在目录 并且列出是否有 别名 whereis命令搜索 以及帮助文档的位置 grep文件内容搜索 grep -iv [指定字符] [文件] -i 不区分大小写 -v 排除指定字符 grep -v ^# /ect/inittab 查找指定文件 忽略以#号开头的行 man帮助命令 manual man ls 查看ls命令目录 同less模式，可以输入/查找相关选项 man services 查看配置文件 man 5 passwd 查看配置文件的帮助信息 1代表命令 ，5代表配置文件 help帮助命令 查看内置命令或者shell 编程语法帮助 useradd添加用户 useradd tanwei 添加用户tanwei passwd tanwei 给新用户设置密码 who查看当前系统登录信息 tty 代表本地登录 pts 代表远程登录 w查看当前系统的登录详细信息和负载 21：35：27 当前系统时间 up 10:54 系统连续运行时间 同命令uptime 2 users 当前登录了多少用户 load average: 系统连续 1分钟之类 5分钟之类 15分钟之类 负载值 IDLE 登录空闲时间 JCPU 当前登录用执行的命令户占用cpu时间 PCPU 当前登录用户执行命令累计占用cpu时间 WHAT 当前用户执行了什么 gzip.gz压缩格式 只能压缩文件，并且不保留源文件 gzip [文件名...] gunzip 或者gzip -d tar.tar.gz 压缩格式 -c 打包 -v 显示详细信息 -f 指定文件名 -z 压缩或解压 -x 解包 tar -zcvf app.tar.gz app 将目录app 压缩打包 并显示详细信息 tar -zxvf app.tar.gz app 将目录app 解压缩 并显示详细信息 zip-r 压缩目录 unzip 解压缩文件 .bz2bzip2压缩格式 之能压缩文件 -k 保留源文件 tar -cjf app.tar.bz2 和tar 搭配使用能够压缩目录 bunzip2 解压缩文件 -k 解压后保留源文件 tar -xjf app.tar.bz2 和tar搭配解压文件 writewrite tanwei 给在线用户tanwei发送命令 Ctrl+D 保存结束 wall(writeall)命令 发送广播消息 ping测试网络连通性 ifcofig(interface configure) 查看设设置网卡信息 mail邮件发送命令 last统计系统用户所有登陆信息 traceroute探测网站路由 netstat查询网络状态信息 netstat -tlun 查询本机开启的端口 netstat -an 查询本机开启的网络端口以及正在链接的网络程序 netstat -rn 查看本机网关 setup配置网络命令 有些系统需要先下载 yum install -y system-config-network-tui mount手动挂载cd mkdir /mnt/cdrom mount /dev/sr0 /mnt/cdrom 讲设备文件名 链接到挂载点 umount /dev/sr0","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"Linux 系统目录的作用","slug":"Linux系统目录的作用","date":"2014-03-31T16:00:00.000Z","updated":"2017-08-05T07:15:56.000Z","comments":true,"path":"2014/04/01/Linux系统目录的作用/","link":"","permalink":"http://blog.vnicers.com/2014/04/01/Linux系统目录的作用/","excerpt":"","text":"/bin存放系统命令的目录(和系统启动有关)，普通用户和超级用户都可以执行，在单用户模式(安全模式)下也可以执行 /sbin系统环境设置相关的命令 只有超级用户可以执行 ，有些命令普通用户可以查看 /usr/bin存放系统相关命令(和系统启动无关),普通用户和超级用户都可以执行，在单用户模式下不可以执行 /usr/sbin存放根文件系统不必要的系统命令，只有超级用户可以执行 /boot系统启动目录，保存系统启动相关文件（内核文件和系统引导程序） /dev系统设备文件 /etc/配置文件目录，系统按照默认安装方式(rpm)安装的文件的配置文件都在该目录下 /home普通用户目录 /liblinux 系统函数库 /lost+found系统意外崩溃或者意外关机产生的一些文件碎片 /midea媒体文件挂载目录 如光盘和软盘 /mntU盘或者移动硬盘和其他操作系统分区挂载目录 /misc挂载NFS服务共享目录 /opt第三方软件保存位置 /proc虚拟文件系统，保存系统内核进程，外部设备状态和网络状态灯。 /sys虚拟文件系统和/proc 类似 主要保存内核相关信息 /svr服务数据目录，一些服务启动后，在这个目录中保存所需要的信息 /tmp系统临时文件目录 所有用户都可以访问和写入 /usr系统软件资源目录 /var动态数据保存目录 主要保存缓存，日志和软件所产生的文件。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vnicers.com/tags/Linux/"}]},{"title":"代理模式","slug":"设计模式-代理模式","date":"2014-03-19T16:00:00.000Z","updated":"2017-08-08T15:37:53.000Z","comments":true,"path":"2014/03/20/设计模式-代理模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/20/设计模式-代理模式/","excerpt":"","text":"代理模式 代理模式为一个对象提供一个替身或占位符控制对这个对象的访问 使用代理模式创建代表对象，让代表对象，控制某对象的访问，被代理的对象可以是远程对象，创建开销大的对象，或需要安全控制的对象。类图： 代理对象类图 首先是Subject,它为RealSubject和Proxy提供了接口。通过实现同一个接口，Proxy在RealSubject出现的地方取代它。RealSubject是真正做事的对象，它是被proxy代理和控制访问的对象。Proxy持有RealSubject的引用。在某些例子里面，Poxy还会负责RealSubject对象的创建和销毁，客户和RealSubject的交互必须通过Proxy,因为Proxy和 RealSubject实现相同的接口，所以任何用到RealSubject的地方，都可以用Proxy取代。Proxy也控制了对RealSubject的访问，在某些情况下，我们需要这样的控制，这些情况包括RealSubject是远程对象，RealSubject创建开销大，或RealSubject需要被保护","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"模板方法模式","slug":"设计模式-模板方法模式","date":"2014-03-17T16:00:00.000Z","updated":"2017-08-08T15:09:18.000Z","comments":true,"path":"2014/03/18/设计模式-模板方法模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/18/设计模式-模板方法模式/","excerpt":"","text":"模板方法模式 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 类图如下： 模板方法定义 这里以煮咖啡和茶的代码作为示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 抽象类Beverage提供了一个prepareRecipe()方法，其中有四个步骤，烧水喝倒入杯子是具体的实现，而冲泡和添加调料则根据不同的子类实现而不同，则定义为抽象的。public abstract class Beverage &#123; final void prepareRecipe()&#123; // 烧水 boliWater(); // 冲泡 brew(); //倒入杯子 pourInCup(); //添加调料 addCondiments(); &#125; protected abstract void addCondiments(); private void pourInCup() &#123; log.info(\"Pouring into cup\"); &#125; protected abstract void brew(); private void boliWater() &#123; log.info(\"boiling water...\"); &#125;&#125;// 咖啡实现类public class Coffee extends Beverage &#123; @Override protected void addCondiments() &#123; log.info(\"Adding Sugar and Milk...\"); &#125; @Override protected void brew() &#123; log.info(\"Dripping Coffe through filter\"); &#125;&#125;// 茶的实现类public class Tea extends Beverage &#123; @Override protected void addCondiments() &#123; log.info(\"Adding Lemon...\"); &#125; @Override protected void brew() &#123; log.info(\"Steeping the tea...\"); &#125;&#125; prepareRecipe方法就是我们的模板方法，为什么？因为： 他是一个方法 它用作一个算法的模板，在这个例子中，算法是用来制作饮料的 模板方法定义了一个算法的步骤，并允许子类为一个或者多个步骤提供实现","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"外观模式","slug":"设计模式-外观模式","date":"2014-03-15T16:00:00.000Z","updated":"2017-08-08T14:51:08.000Z","comments":true,"path":"2014/03/16/设计模式-外观模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/16/设计模式-外观模式/","excerpt":"","text":"外观模式 外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。 外观模式很容易理解，外观的意图是提供一个简单的接口，好让一个子系统更易于使用，从这个模式的类图可以感受到这一点 外观模式的类图 最少知识原则最少知识原则告诉我们要减少对象之间的交互，只留下几个密切先关的类。这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分，如果允许多类之间的相互依赖，那么这个系统就会变成一个易碎的系统。它需要花很多成本维护，也会因为太复杂而不会被其他人理解。","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"适配器模式","slug":"设计模式-适配器模式","date":"2014-03-14T16:00:00.000Z","updated":"2017-08-08T08:45:57.000Z","comments":true,"path":"2014/03/15/设计模式-适配器模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/15/设计模式-适配器模式/","excerpt":"","text":"适配器模式 适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作。 适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者：这种做法还有额外的优点，那就是被适配者的任何子类，都可以搭配着适配器使用。 适配器模式示意图 面向对象适配器 将火鸡包装成鸭子的适配器代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Duck &#123; void quack(); void fly();&#125;public class MallardDuck implements Duck &#123; @Override public void quack() &#123; log.info(\"Quack \"); &#125; @Override public void fly() &#123; log.info(\"I'm flying\"); &#125;&#125;public interface Turkey &#123; void gobble(); void fly();&#125;public class WildTurky implements Turkey &#123; @Override public void gobble() &#123; log.info(\"Gobble gobble\"); &#125; @Override public void fly() &#123; log.info(\"I'm flying a short distance\"); &#125;&#125;public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey=turkey; &#125; @Override public void quack() &#123; this.turkey.gobble(); &#125; @Override public void fly() &#123; this.turkey.fly(); &#125;&#125; 客户使用适配器的过程如下客户通过目标接口调用适配器的方法对适配器发出请求 适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口 客户接收到调用的结果，但并未察觉到这一切都是是配置在起转换作用。 类图","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"命令模式","slug":"设计模式-命令模式","date":"2014-03-10T16:00:00.000Z","updated":"2017-08-08T07:59:11.000Z","comments":true,"path":"2014/03/11/设计模式-命令模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/11/设计模式-命令模式/","excerpt":"","text":"命令模式定义 将请求封装成对象，以便使用不同的请求，队列，或者日志来参数化其他对象。命令模式也可以支持可测销操作。 命令模式示意图 命令模式 遥控器控制电灯打开的java代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 一个普通的执行命令对象public class Light &#123; public void on()&#123; log.info(\"light on...\"); &#125;&#125;public interface Command &#123; // 命令接口只需要一个简单的执行方法 void execute();&#125;//一个具体的命令实现，其中包含执行命令的对象lightpublic class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light=light; &#125; // 当执行命令的时候，电灯打开 @Override public void execute() &#123; this.light.on(); &#125;&#125;// 遥控控制类，包含一个命令插口引用，可以设置不同的命令public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl()&#123;&#125; public void setCommand(Command command)&#123; this.slot=command; &#125; // 当按钮按下的时候，调用插口实现的命令执行命令 public void buttonWasPressed()&#123; this.slot.execute(); &#125;&#125;// 代码测试public class RemoteControlTest &#123; public static void main(String[] args) &#123; SimpleRemoteControl remote=new SimpleRemoteControl(); Light light=new Light(); // 创建一个打开电灯的命令，将电灯传进去 LightOnCommand lightOnCommand=new LightOnCommand(light); // 遥控器设置一个命令 remote.setCommand(lightOnCommand); // 按下按钮执行命令 remote.buttonWasPressed(); &#125;&#125;","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"单例模式","slug":"设计模式-单例模式","date":"2014-03-07T16:00:00.000Z","updated":"2017-08-08T05:29:30.000Z","comments":true,"path":"2014/03/08/设计模式-单例模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/08/设计模式-单例模式/","excerpt":"","text":"单例模式 确保一个类只有一个实例，并提供一个全局的访问点 最简单的形式12345678910111213public class Singleton1 &#123; private static Singleton1 uniqueInstance; private Singleton1() &#123; &#125; public static Singleton1 getInstance()&#123; if(uniqueInstance==null)&#123; uniqueInstance=new Singleton1(); &#125; return uniqueInstance; &#125;&#125; 上面的代码很容易理解，将构造函数私有化，在静态方法getInstance中，如果不调用getInstance方法，那么这个对象永远不会产生，这是一个延迟实例化 在多线程状态下的问题因为getInstance方法中的代码不是原子的。如果多个线程同时执行，则有可能产生多个实例。具体是怎样产生的看下图 多线程情况下获取到多个实例 使用同步处理多线程产生多个实例的问题12345678910111213public class Singleton2 &#123; private static Singleton2 uniqueInstance; private Singleton2() &#123; &#125; public static synchronized Singleton2 getInstance()&#123; if(uniqueInstance==null)&#123; uniqueInstance=new Singleton2(); &#125; return uniqueInstance; &#125;&#125; 只需要在getInstance方法声明中添加 synchronized 关键字就可以解决问题，保证在多线程情况下，同时只有一个线程能够进入这个方法但是同步会降低性能，每次调用getInstance方法的时候，都需要同步，但是我们在获取到第一个实例之后，后面都不需要同步。在方法声明上设置同步是一种累赘 改善方法同步的问题如果引用性能问题不是很关键那么什么都别做使用饿汉式创建单例模式12345678910public class Singleton3 &#123; private static Singleton3 uniqueInstance =new Singleton3(); private Singleton3() &#123; &#125; public static Singleton3 getInstance()&#123; return uniqueInstance; &#125;&#125; 使用饿汉式创建单例，JVM在加载这个类时间，马上创建唯一的单例实例，保证在任何线程访问uniqueInstance静态变量之前，一定要先创建此实例。 懒汉式双重检查锁1234567891011121314151617public class Singleton4 &#123; private volatile static Singleton4 uniqueInstance; private Singleton4() &#123; &#125; public static Singleton4 getInstance()&#123; if(uniqueInstance==null)&#123; synchronized (Singleton4.class) &#123; if (uniqueInstance==null) &#123; uniqueInstance = new Singleton4(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 利用双重检查锁，首先检查实例是否已经创建，，如果尚未创建，才进行同步，这样一来，只会有第一次会同步，如果性能是你关心的重点，那么这个做法可以帮你打打减少getInstance的时间耗费注意 这里使用了 volatile 保证在多线程的情况下，对修饰的对象的内存可见性。","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"工厂模式","slug":"设计模式-工厂模式","date":"2014-03-06T16:00:00.000Z","updated":"2017-08-08T10:25:27.000Z","comments":true,"path":"2014/03/07/设计模式-工厂模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/07/设计模式-工厂模式/","excerpt":"","text":"工厂模式 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类 new对象的问题 当使用new 关键之创建一个对象的时候，你是在实例化一个具体的类，你使用的是实现，而不是接口。代码绑定着具体的类会导致代码更脆弱，更缺乏弹性。 例如如下代码,有一大堆不同的鸭子实现类时，但是必须等到运行时，才知道该实例化哪一个 12345678Duck duck;if (picnic) &#123; duck = new MallardDuck();&#125; else if (hunting) &#123; duck = new DecoyDuck();&#125; else if (inBathTub) &#123; duck = new RubberDuck();&#125; 当看到这样的代码，一旦有变化或者扩展，就必须冲洗打卡这段代码进行检查和修改，通常修改这样的代码将造成部分系统更难维护和更新，而且也更容易犯错。在技术上new 对象没有错，毕竟这是Java的基础部分，真正的的问题是我们的程序需要改变。针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。如果代码是针对接口而写，那么通过多态，它可以与任何新类实现该接口，但是当代码使用大量的具体类时，就是自找麻烦，因为一旦加入具体的类，就必须改变代码，也就是说你的代码并非”对修改关闭” 简单工厂简单工厂只负责创建对象，这个工厂可能不止服务于一个地方，以后对象类型如果有变动，只需修改简单工厂的逻辑就可以1234567891011121314public class SimplePizzaFactory &#123; public Pizza createPizza(String type)&#123; Pizza pizza=null; if(\"\".equals(type))&#123; pizza= new CheesePizza(); &#125;else if (\"Clam\".equals(type))&#123; pizza=new ClamPizza(); &#125;else if (\"Greek\".equals(type))&#123; pizza=new GreekPizza(); &#125; return pizza; &#125;&#125; 使用简单工厂，将new对象的操作移动到了简单工厂中，这里只传入订单类型来使用工厂创建对象123456789101112public class SimplePizzaStore &#123; SimplePizzaFactory simplePizzaFactory; public SimplePizzaStore(SimplePizzaFactory factory)&#123; this.simplePizzaFactory=factory; &#125; public Pizza orderPizza(String type)&#123; Pizza pizza=this.simplePizzaFactory.createPizza(type); return pizza; &#125;&#125; 简单工厂其实是一种常用的编程习惯，而不是一种设计模式。 工厂方法使用简单工厂只能穿件简单工厂中一种模式的对象，现在我们想使用不同的工厂创建不同的对象 123456789public abstract class AbstractPizzaStore &#123; public final Pizza orderPizza(String type)&#123; Pizza pizza=createPizza(type); return pizza; &#125; protected abstract Pizza createPizza(String type);&#125; 将创建pizza对象的方法抽象到PizzaStore中，然后让具体的子类去实现不同的创建方式，同时，将orderPizza方法在本类中设置为final，这个方法因为比较固定， 防止子类覆盖掉该方法 具体的pizza 店根据自己的需求创建不同风味的pizza1234567891011121314public class ChinesePizzaStore extends AbstractPizzaStore &#123; @Override protected Pizza createPizza(String type) &#123; if (\"chesses\".equals(type)) &#123; return new ChineseStyleCheesePizza(); &#125; else if (\"clam\".equals(type)) &#123; return new ChineseStyleClamPizza(); &#125; else &#123; return new ChineseStyleCheesePizza(); &#125; &#125;&#125; 测试入口123456public class Main&#123; public static void main(String[] args)&#123; PizzStore pizzStore=new ChinesePizzStore(); pizzStore.orderPizza(\"cheese\"); &#125;&#125; 工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样，客户程序中关于超类的代码就和子类对象创建代码解耦了 工厂方法中抽象方法原型 所有工厂模式都用来封装对象的创建，工厂方法模式，通过让子类决定该创建什么样的对象，来达到将对象创建过程封装的目的，让我们来看看这些类图。 工厂方法模式能够封装具体类型的实例化，看看下面的类图，抽象的Creator提供了一个创建对象的方法接口，也称为”工厂方法”，在抽象的Creator中，任何其他实现的方法，都可以使用到这个工厂方法所制造出来的产品，但是只有子类真正实现这个工厂方法并穿件产品。 抽象工厂从上面的代码中可以看到，PizzaStore中依赖了具体的Pizza类。而设计原则中有一条要依赖抽象类，不要依赖具体的类，这也是依赖倒置原则(Dependency Inversion Principle),这个原则应该告诉我们重写代码以便于我们依赖抽象类，而不是具体的类。对于高层次及低层次模块都应该如此。 原则的应用非常依赖PizzStore的主要问题在于，它依赖每个披萨类型，因为它是在自己的orderPizza方法中。实例化这些具体类型。 在为各种不同的PizzStore提供不同的原料时，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface PizzaIngredientFactory &#123; Dough createDough(); Sauce createSauce(); Cheese createCheese(); Clam createClam();&#125;public class NYPizzaIngredientFactory implements PizzaIngredientFactory &#123; @Override public Dough createDough() &#123; return new ThinCrustDough(); &#125; @Override public Sauce createSauce() &#123; return new MarinaraSauce(); &#125; @Override public Cheese createCheese() &#123; return new ReggianoCheese(); &#125; @Override public Clam createClam() &#123; return new FreshClams(); &#125;&#125;public class CheesePizza extends AbstractPizza &#123; PizzaIngredientFactory ingredientFactory; public CheesePizza(PizzaIngredientFactory factory) &#123; this.ingredientFactory = factory; &#125; @Override void prepare() &#123; log.info(\"Preparing ....\"); super.dough = this.ingredientFactory.createDough(); super.cheese = this.ingredientFactory.createCheese(); super.clam = this.ingredientFactory.createClam(); super.sauce = this.ingredientFactory.createSauce(); &#125;&#125;&#125;public class NYPizzaStore extends AbstractPizzaStore &#123;public class NYPizzaStore extends AbstractPizzaStore &#123; @Override protected Pizza createPizza(String item) &#123; Pizza pizza=null; PizzaIngredientFactory ingredientFactory=new NYPizzaIngredientFactory(); if (item.equals(\"cheese\")) &#123; pizza = new CheesePizza(ingredientFactory); pizza.setName(\"New York Style Cheese Pizza\"); &#125; else if (item.equals(\"clam\")) &#123; pizza = new ClamPizza(ingredientFactory); pizza.setName(\"New York Style Clam Pizza\"); &#125; return pizza; &#125;&#125; 我们引入了新类型的工厂，也就是所谓的抽象工厂，来创建原料家族。通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口书写代码，我们的代码将从实际工厂解耦，以便在不同上下文中实现各式各样的工厂，制造出各种不同的产品。因为代码从实际的产品中解耦了，所以我们可以替换不同的工厂来取得不同的行为。AbstractPizza 的代码利用相关的工厂生产原料。所生产的原料依赖所使用的工厂，Pizza类根本不关心这些原料。它只知道如何制作披萨。现在Pizza和区域原料之间被解耦。下面是抽象工厂的类图关系 抽象工厂 抽象工厂定义 抽象工厂提供了一个接口，用于创建相关领域或者依赖对象的家族，而不需要明确指定具体的类","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"装饰器模式","slug":"设计模式-装饰器模式","date":"2014-03-04T16:00:00.000Z","updated":"2017-08-07T12:41:09.000Z","comments":true,"path":"2014/03/05/设计模式-装饰器模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/05/设计模式-装饰器模式/","excerpt":"","text":"装饰器模式 装饰器模式动态的将责任附加到对象上。若要扩展功能，装饰器提供了比继承更有弹性的替代方案。 装饰器模式，如果大家使用过java.io包下的字节流或者字符流就应该比较熟悉了。这里先列举一下IO包下的相关类 Java IO 流 使用装饰器模式设计一个关于饮料的java代码实现 下面是一个饮料的抽象类，有一个描述熟悉和抽象的价格方法。默认的描述方法返回未知名称的饮料，价格方法则由子类去自己实现12345678910public abstract class Beverage &#123; private String description=\"Unknow Beverage\"; public String getDescription() &#123; return description; &#125; public abstract double cost();&#125; 下面是带有调料的装饰器，继承了饮料类，抽象了描述方法。 123public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription();&#125; 具体的抹茶饮料继承了调料类，实现了描述，和价格方法，同时在构造方法中传入了饮料对象。在具体实现描述和价格方法中，使用到了饮料类的方法，在此之上做了一些改动。123456789101112131415161718public class Mocha extends CondimentDecorator &#123; private Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return this.beverage.getDescription() + \", Mocha\"; &#125; @Override public double cost() &#123; return this.beverage.cost() + .20; &#125;&#125; 以上，装饰着做得事就是增加行为到被包装的对象上。 但是 装饰器模式有一个缺点，从Java IO流的API可以看出，利用装饰器模式，常常造成设计中有大量的小类，数量太多了会造成使用者的困扰。","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"观察者模式","slug":"设计模式-观察者模式","date":"2014-03-02T16:00:00.000Z","updated":"2017-08-07T12:22:23.000Z","comments":true,"path":"2014/03/03/设计模式-观察者模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/03/设计模式-观察者模式/","excerpt":"","text":"观察者模式 观察者模式定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，他的所有依赖都会接受到通知并自动更新。 认识观察者，直接看下Head First 设计模式书中给出的一张图就可以很容易理解观察值模式的定义 观察者模式示意图 程序实现 观察者主题类-天气主题，提供天气数据weathDTO12345678910111213public class WeatherSubject extends Observable &#123; private WeatherDTO weatherDTO; public void setWeatherDTO(WeatherDTO weatherDTO) &#123; this.weatherDTO = weatherDTO; setChanged(); notifyObservers(); &#125; public WeatherDTO getWeatherDTO() &#123; return weatherDTO; &#125;&#125; 天气主题订阅类-当前天气显示面板类123456789101112131415161718192021222324public class CurrentConditionDisplay implements Observer, DisplayElement &#123; private WeatherDTO weatherDTO; public CurrentConditionDisplay(Observable observable) &#123; observable.addObserver(this); &#125; @Override public void display() &#123; log.info(\"Current conditions: Temperature:&#123;&#125;,Humidity:&#123;&#125;\", weatherDTO.getTemperature(), weatherDTO.getHumidity()); &#125; @Override public void update(Observable o, Object arg) &#123; if(o instanceof WeatherSubject) &#123; WeatherSubject weatherSubject = (WeatherSubject) o; this.weatherDTO=weatherSubject.getWeatherDTO(); this.display(); &#125; &#125;&#125; 程序测试入口1234567public class WheaterStation &#123; public static void main(String[] args) &#123; WeatherSubject weatherSubject=new WeatherSubject(); CurrentConditionDisplay display=new CurrentConditionDisplay(weatherSubject); weatherSubject.setWeatherDTO(new WeatherDTO(80,65,30.4f)); &#125;&#125; 当天气主题发布新的天气信息的时候，显示面板则马上收到新的数据显示。 注意上面的WeatherSubject继承的是java.util.Observable,下面是其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/** * This class represents an observable object, or \"data\" * in the model-view paradigm. It can be subclassed to represent an * object that the application wants to have observed. * &lt;p&gt; * An observable object can have one or more observers. An observer * may be any object that implements interface &lt;tt&gt;Observer&lt;/tt&gt;. After an * observable instance changes, an application calling the * &lt;code&gt;Observable&lt;/code&gt;'s &lt;code&gt;notifyObservers&lt;/code&gt; method * causes all of its observers to be notified of the change by a call * to their &lt;code&gt;update&lt;/code&gt; method. * &lt;p&gt; * The order in which notifications will be delivered is unspecified. * The default implementation provided in the Observable class will * notify Observers in the order in which they registered interest, but * subclasses may change this order, use no guaranteed order, deliver * notifications on separate threads, or may guarantee that their * subclass follows this order, as they choose. * &lt;p&gt; * Note that this notification mechanism has nothing to do with threads * and is completely separate from the &lt;tt&gt;wait&lt;/tt&gt; and &lt;tt&gt;notify&lt;/tt&gt; * mechanism of class &lt;tt&gt;Object&lt;/tt&gt;. * &lt;p&gt; * When an observable object is newly created, its set of observers is * empty. Two observers are considered the same if and only if the * &lt;tt&gt;equals&lt;/tt&gt; method returns true for them. * * @author Chris Warth * @see java.util.Observable#notifyObservers() * @see java.util.Observable#notifyObservers(java.lang.Object) * @see java.util.Observer * @see java.util.Observer#update(java.util.Observable, java.lang.Object) * @since JDK1.0 */public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; /** * Adds an observer to the set of observers for this object, provided * that it is not the same as some observer already in the set. * The order in which notifications will be delivered to multiple * observers is not specified. See the class comment. * * @param o an observer to be added. * @throws NullPointerException if the parameter o is null. */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * Deletes an observer from the set of observers of this object. * Passing &lt;CODE&gt;null&lt;/CODE&gt; to this method will have no effect. * @param o the observer to be deleted. */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * If this object has changed, as indicated by the * &lt;code&gt;hasChanged&lt;/code&gt; method, then notify all of its observers * and then call the &lt;code&gt;clearChanged&lt;/code&gt; method to * indicate that this object has no longer changed. * &lt;p&gt; * Each observer has its &lt;code&gt;update&lt;/code&gt; method called with two * arguments: this observable object and &lt;code&gt;null&lt;/code&gt;. In other * words, this method is equivalent to: * &lt;blockquote&gt;&lt;tt&gt; * notifyObservers(null)&lt;/tt&gt;&lt;/blockquote&gt; * * @see java.util.Observable#clearChanged() * @see java.util.Observable#hasChanged() * @see java.util.Observer#update(java.util.Observable, java.lang.Object) */ public void notifyObservers() &#123; notifyObservers(null); &#125; /** * If this object has changed, as indicated by the * &lt;code&gt;hasChanged&lt;/code&gt; method, then notify all of its observers * and then call the &lt;code&gt;clearChanged&lt;/code&gt; method to indicate * that this object has no longer changed. * &lt;p&gt; * Each observer has its &lt;code&gt;update&lt;/code&gt; method called with two * arguments: this observable object and the &lt;code&gt;arg&lt;/code&gt; argument. * * @param arg any object. * @see java.util.Observable#clearChanged() * @see java.util.Observable#hasChanged() * @see java.util.Observer#update(java.util.Observable, java.lang.Object) */ public void notifyObservers(Object arg) &#123; /* * a temporary array buffer, used as a snapshot of the state of * current Observers. */ Object[] arrLocal; synchronized (this) &#123; /* We don't want the Observer doing callbacks into * arbitrary code while holding its own Monitor. * The code where we extract each Observable from * the Vector and store the state of the Observer * needs synchronization, but notifying observers * does not (should not). The worst result of any * potential race-condition here is that: * 1) a newly-added Observer will miss a * notification in progress * 2) a recently unregistered Observer will be * wrongly notified when it doesn't care */ if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; /** * Clears the observer list so that this object no longer has any observers. */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * Marks this &lt;tt&gt;Observable&lt;/tt&gt; object as having been changed; the * &lt;tt&gt;hasChanged&lt;/tt&gt; method will now return &lt;tt&gt;true&lt;/tt&gt;. */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * Indicates that this object has no longer changed, or that it has * already notified all of its observers of its most recent change, * so that the &lt;tt&gt;hasChanged&lt;/tt&gt; method will now return &lt;tt&gt;false&lt;/tt&gt;. * This method is called automatically by the * &lt;code&gt;notifyObservers&lt;/code&gt; methods. * * @see java.util.Observable#notifyObservers() * @see java.util.Observable#notifyObservers(java.lang.Object) */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** * Tests if this object has changed. * * @return &lt;code&gt;true&lt;/code&gt; if and only if the &lt;code&gt;setChanged&lt;/code&gt; * method has been called more recently than the * &lt;code&gt;clearChanged&lt;/code&gt; method on this object; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see java.util.Observable#clearChanged() * @see java.util.Observable#setChanged() */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * Returns the number of observers of this &lt;tt&gt;Observable&lt;/tt&gt; object. * * @return the number of observers of this object. */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 注意： 这个类从JDK1.0就已经存在，它是一个类而不是一个接口，这就导致我们的主题类继承了Observable之后就无法继承其他类。违反了面向对象设计原则：针对接口编程，而不是针对实现编程。所以更多的时候我们需要自己去创建Observable接口。","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"策略模式","slug":"设计模式-策略模式","date":"2014-02-28T16:00:00.000Z","updated":"2017-08-07T08:39:38.000Z","comments":true,"path":"2014/03/01/设计模式-策略模式/","link":"","permalink":"http://blog.vnicers.com/2014/03/01/设计模式-策略模式/","excerpt":"","text":"策略模式 策略模式定义一系列算法，分别封装起来，让他们之间可以相互转换，策略模式可以让算法的变化独立于使用算法的客户。 12345678910111213141516171819202122232425262728293031323334public abstract class Duck &#123; private FlyBehavior flyBehavior; private QuackBehavior quackBehavior; public Duck() &#123; this.flyBehavior=new FlyBehaviorDefualtImpl(); this.quackBehavior=new QuackBehaviorDefaultImpl(); &#125; public void performFly()&#123; this.flyBehavior.fly(); &#125; public void performQuack()&#123; this.quackBehavior.quack(); &#125; public void swim()&#123; log.info(\"All ducks float, event decoys\"); &#125; abstract void display(); public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 定义了一个抽象的鸭子基类，它有最基本的四个方法，执行飞的行为方法performFly(),执行叫的行为方法performQuack()，还有游泳和显示方法。不同的鸭子子类显示行为不同，所以这里设置成abstract的。所有的鸭子都可以游泳。这里直接定义好一个具体的方法swim，但是鸭子的飞和叫方法，不同的子类是不同、，虽然这里也可以将这两个方法设计成抽象的方法，由具体的子类去实现，但是当鸭子的子类非常多的时候，各自都需要重新实现飞和叫的方法。这里为了复用而使用继承，并不完美。因为你很难知道以后这个抽象基类会新增什么其他的抽象方法，那样所有的具体子类都需要实现这个抽象方法。运行时的行为也不容易改变，这里可以使用策略模式将变化的部分单独封装起来，好让其他部分不受影响，这里有一个设计原则 找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。 可以将鸭子的行为单独的放在分开的类中，此类专门提供某行为接口实现，这样鸭子类就不再需要知道行为的实现细节。 1234567891011121314151617181920 public interface FlyBehavior &#123; void fly(); &#125; public class FlyBehaviorDefualtImpl implements FlyBehavior &#123; @Override public void fly() &#123; log.info(\"I'am flying !\"); &#125; &#125;public class FlyNoWayBehaviorImpl implements FlyBehavior &#123; @Override public void fly() &#123; log.info(\"I canot fly!\"); &#125;&#125; 这样设计的好处是可以动态的改变鸭子的行为，只需要set不同的behavior实现就行了12345678910111213141516171819public static void main(String[] args) &#123; Duck duck=new MallardDuck(); log.info(\"默认行为&gt;&gt;&gt;&gt;&gt;&gt;&gt;.\"); duck.display(); duck.performFly(); duck.performQuack(); log.info(\"动态改变行为&gt;&gt;&gt;&gt;&gt;&gt;&gt;.\"); duck.setFlyBehavior(new FlyNoWayBehaviorImpl()); duck.setQuackBehavior(new MuteQuackBehaviorImpl()); duck.display(); duck.performFly(); duck.performQuack(); &#125;","categories":[{"name":"Head First 设计模式","slug":"Head-First-设计模式","permalink":"http://blog.vnicers.com/categories/Head-First-设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.vnicers.com/tags/设计模式/"}]},{"title":"Spring JDBC 设计与实现","slug":"Spring JDBC 设计与实现","date":"2014-02-19T16:00:00.000Z","updated":"2017-08-07T08:39:38.000Z","comments":true,"path":"2014/02/20/Spring JDBC 设计与实现/","link":"","permalink":"http://blog.vnicers.com/2014/02/20/Spring JDBC 设计与实现/","excerpt":"","text":"","categories":[{"name":"Spring 源码分析","slug":"Spring-源码分析","permalink":"http://blog.vnicers.com/categories/Spring-源码分析/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"DispatcherServlet 设计和原理","slug":"DispatcherServlet 设计和原理 ","date":"2014-02-17T16:00:00.000Z","updated":"2017-08-07T07:39:27.000Z","comments":true,"path":"2014/02/18/DispatcherServlet 设计和原理 /","link":"","permalink":"http://blog.vnicers.com/2014/02/18/DispatcherServlet 设计和原理 /","excerpt":"","text":"在Spring MVC中 ,看到了在web.xml中 , 除了需要配置ContextLoaderListener之外 , 还要对 DispatcherServlet迸行配置作为一个Servlet,这个DispatcherServlet实现的是Sun的J2EE核 心模式中的前端控制器模式 (Front Control1er), 作为一个前端控制器 ,所有的Web诘求都需要通过它来处理 , 进行转发 、 匹配、 数据处理后 , 井转由页面迸行展现 , 因此这个 DispatcherServlet可以看成是Spring MVC实现中最为核心的部分, 它的设计与分析也是下面分 祈Spring MVC的一条主线。 在完成对ContextLoaderListener的初始化以后 , Web容器开始初始化DispatcherServlet, 这个初始化的启动与在web.xml中对载入次序的定义有关。 DispatcherServlet会建立 自 己的上 下文来持有Spring MVC的Bean对象 , 在建立这个自己持有的loC容器时,会从ServletContext中得到根上下文作为DispatcherServlet持有上下文的双亲上下文，有了这个根上下文，再对自己持有的根上下文进行初始化，最后把自己持有的这个上下文保存到ServletContext，供以后使用。 为了解这个过程 , 可以从DispatcherServlet的父类 FrameworkServlet的代码入手, 去探寻DispatcherServlet的启动过程, 它同时也是Spring MVC的启动过程. ApplicationContext的创建过程和ContextLoader创建根上下文的过程有许多类似的地方. 从源码的分析中发现DispatcherServlet的类继承关系为HttpServletBean-&gt;FrameworkServlet-&gt;DispatchServlet 具体执行过程如下 DispatcherServlet执行过程 作为一个Servlet ，Web容器会调用Servlet的doGet或者doPost方法，在经过FrameworkServlet的processRequest的简单处理后，会调用DispatcherServlet的doService方法，在这个方法调用中，封装课doDispatch(),这个doDispatch是Dispatch实现MVC模式的主要部分。 DispatchServlet的启动和初始化作为Servlet, DispatcherServlet的启动与Servlet的启动过程是相联系的。在Servlet的初始化过程中, Servlet的init方法会被调用, 以迸行初始化， DispatcherServlet的基类 HtlpServletBean中的这个初始化过程如上图所示。 在初始化开始时, 需要读取配置在ServletContext中 的Bean属性参数, 这些属性参数设置在web.xml的web容器初始化参数中 . 使用编程式的方式来设置这些Bean属性, 在这里可以看到对PropertyValues和BeanWrapper的使用. 对于这些和依赖注入相关的类的使用, 在分析IOC容器的初始化时. 尤其是在依赖注入实现分析时, 有提到过。 只是这里的依赖注入是与web容器初始化相关的, 初始化过程由HttpServletBean来 完成。 接着会执行DispatchServlet持有的IOC容器的初始化过程, 在这个初始化过程中, 一个新的上下文被建立起来, 这个DispatchServlet持有的上下文被设置为根上下文的子上下文. 可以认为, 根上下文是和Web应用相对应的一个上下文, 而DispatchServlet持有的上下文是 和Servlet对应的一个上下文. 在一个Web应用中, 往往可以容纳多个Servlet存在 与此相对应，对于应用在Web容器中的上下文体系，一个根上下文可以作为许多Servlet上下文的双亲上下文。了解IoC工作原理都知道在向IoC容器中getBean时，IoC容器会首先向其双亲上下文去getBean，也就是说，在根上下文中定义的Bean是可以被各个Servlet持有的上下文得到和共享的。DispatcherServlet上下文在建立起来以后，也需要和其他IoC容器一样完成初始化，这个初始化也是通过resfresh方法完成的。最后DispatchServlet给这个自己持有的上下文命名，并把它设置到Web容器的上下文中，这个名称和在Web.xml设置的DispatchServlet的Servlet名称有关。从而保证了这个上下文在Web环境上下文体系中的唯一性 HttpServletBean init方法123456789101112131415161718192021222324252627282930public final void init() throws ServletException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Initializing servlet '\" + this.getServletName() + \"'\"); &#125; //获取Servlet init param参数 PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment())); this.initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException var4) &#123; if (this.logger.isErrorEnabled()) &#123; this.logger.error(\"Failed to set bean properties on servlet '\" + this.getServletName() + \"'\", var4); &#125; throw var4; &#125; &#125; // FramworkServlet中执行具体的initServletBean this.initServletBean(); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Servlet '\" + this.getServletName() + \"' configured successfully\"); &#125; &#125; 123456789101112131415161718192021222324252627protected final void initServletBean() throws ServletException &#123; this.getServletContext().log(\"Initializing Spring FrameworkServlet '\" + this.getServletName() + \"'\"); if (this.logger.isInfoEnabled()) &#123; this.logger.info(\"FrameworkServlet '\" + this.getServletName() + \"': initialization started\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 先初始化上下文，在initWebApplicationContext方法中，先拿到ContextLoaderListeners加载过得根上下文，然后通过BeanUtils //创建一个子上下文，设置必要的属性，然后再存到ServletContext中去。 this.webApplicationContext = this.initWebApplicationContext(); this.initFrameworkServlet(); &#125; catch (ServletException var5) &#123; this.logger.error(\"Context initialization failed\", var5); throw var5; &#125; catch (RuntimeException var6) &#123; this.logger.error(\"Context initialization failed\", var6); throw var6; &#125; if (this.logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + this.getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); &#125; &#125; DispatcherSerlvet持有一个以自己的Serverlet名称命名的IoC容器。这个IoC容器是一个WebApplicationContext对象，这个IoC容器建立起来后，意味着DispatchServlet拥有自己的Bean定义空间，这为使用各个独立的XML文件来配置MVC中各个Bean创造了条件，由于初始化结束以后，与Web容器相关的初始化过程实际上已经完成，Spring MVC 的具体实现，和普通的Spring 应用的程序的实现并没有太大的差别。在Spring MVC DispatchServet的初始化过程中，以对HandlerMapping的初始化调用为触发点了解，这个调用关系最初是有HttpServletBean的init方法触发的，这个HttpServletBean是HttpServlet的子类。 接着会在HttpServletBean的子类FrameworkServlet中对IoC容器完成初始化，在这个初始化的方法中，会调用DispatchServlet的initStrategies方法，在这个方法中，启动整个Spring MVC 框架的初始化。 1234567891011protected void initStrategies(ApplicationContext context) &#123; this.initMultipartResolver(context); this.initLocaleResolver(context); this.initThemeResolver(context); this.initHandlerMappings(context); this.initHandlerAdapters(context); this.initHandlerExceptionResolvers(context); this.initRequestToViewNameTranslator(context); this.initViewResolvers(context); this.initFlashMapManager(context); &#125; 根据上面的方法名称，很容易理解，以HandlerMappering为例来说明这个initHandlerMappings过程。，这里的Mapping的关系作用是，以Http请求找到相应的Controller控制器，从而利用这些控制器Controller去完成设计好的数据处理工作，HandlerMappings完成对MVC中Controller的定义和配置。 HandlerMapping的配置和设计原理在初始化完成时，在上下文环境中定义的素有HandlerMapping都已经被加载了，这些加载的HandlerMapping 被放在一个List中被排序，存储着Http请求对应的映射数据，这个List中的每一个元素都对应着一个具体的handlerMapping配置。以SimpleUrlHandlerMapping这个handlerMapping为例子，分析HandlerMapping的设计与实现，在SimpleHandlerMapping中，定义一个map来持有一系列的映射关系，通过这些映射关系，使SpringMVC 应用可以根据 Http请求确定一个对应的Controller.","categories":[{"name":"Spring 源码分析","slug":"Spring-源码分析","permalink":"http://blog.vnicers.com/categories/Spring-源码分析/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"Spring AOP","slug":"Spring AOP","date":"2014-02-14T16:00:00.000Z","updated":"2017-08-06T13:05:48.000Z","comments":true,"path":"2014/02/15/Spring AOP/","link":"","permalink":"http://blog.vnicers.com/2014/02/15/Spring AOP/","excerpt":"","text":"AOP 是Spring框架的核心功能模块之一。AOP与IoC容器的结合使用，为应用开发或者Spring自身功能的扩展都提供了便利。Spring AOP的实现和其他特性的实现一样，除了可以使用Spring 本身提供的AOP实现之外，还封装了业界优秀的AOP解决方案AspectJ来供使用。 Advice 通知Advice通知定义在连接点做什么，为切面增强提供织如接口。在Spring AOP 中它主要描述Spring AOP围绕方法调用而注入的切面行为，在SpringAOP 实现使用了AOP联盟定义的同一接口org.aopalliance.aop.Advice，通过这个接口，为AOP切面增强的织入功能做了更多的细化和扩展，比如提供了更具体的通知类型，如BeforeAdvice,AfterAdvice,ThrowsAdvice.作为Spring AOP 定义的接口类，具体的切面增强可以通过这些接口集成到AOP框架中去发挥作用。 BeforeAdvice在BeforeAdvice 的继承关系关系中，定义了为待增强的目标方法设置 前置增强接口MethodBeforeAdvice AfterReturningAdvice在目标方法调用结束并成功返回的时候，会执行回调函数afterReturning ThrowsAdvice在抛出异常时会回调afterThrowing方法 Pointcut 切点切点决定Advice通知应该作用于哪个连接点，也就是说通过Pointcut来定义需要增强的方法的集合切点的类继承关系如下 pointcut Advisor完成对目标方法的切面增强设计(Advice)和关注点的设计(Pointcut)以后，需要一个对象将他们结合起来，完成这个作用的就是Advisor通知器，把Advice和Pointcut结合起来，这个结合为使用IoC容器配置AOP应用，或者说即开即用的AOP基础设施，提供了便利 JVM 动态代理的特性在Spring AOP中，使用核心技术的是动态代理，而这种动态代理实际上是JDK的一个特性。通过JDK的动态代理，可以为任意对象创建代理对象，对弈具体使用来说，这个特性是通过Java Reflection API 来完成的。 设计原理在Spring的AOP模块中，一个主要的部分是代理对象的生成，而对于Spring应用，可以看到，是通过配置和调用Spring的ProxyFactoryBean来完成这个任务的在ProxyFactoryBean中封装了主要的代理对象的生成过程。在这个过程中可以使用JDK的Proxy或者是CGLIB 在分析Spring AOP 的实现原理中，主要以ProxyFactoryBean的实现作为例子和实现的基本线索进行分析这是因为ProxyFactoryBean是在Spring IoC环境中创建 AOP 应用的底层方法，也是最灵活的方法，Spring通过它完成了对AOP使用封装。以ProxyFactoryBean实现为入口，逐层深入是学习理解Spring AOP 实现的学习路径 AopProxy生成过程","categories":[{"name":"Spring 源码分析","slug":"Spring-源码分析","permalink":"http://blog.vnicers.com/categories/Spring-源码分析/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"Spring MVC","slug":"Spring MVC","date":"2014-02-14T16:00:00.000Z","updated":"2017-08-07T07:39:27.000Z","comments":true,"path":"2014/02/15/Spring MVC/","link":"","permalink":"http://blog.vnicers.com/2014/02/15/Spring MVC/","excerpt":"","text":"概要 Spring MVC 是建立在IoC容器的基础之上的。了解Spring MVC，首先要了解Spring IoC容器是如何在Web环境中被载入，并起作用的 Spring IoC是一个独立的模块，它并不是直接在Web容器中发挥作用的，如果在Web环境中使用IoC容器，需要为IoC设计一个启动过程，将IoC容器载入，并在Web容器中建立起来，这个过程是和Web容器的启动过程是建立在一起的。在这个过程中，一方面处理Web容器的启动，另一方面通过设定特定的Web容器拦截器或者监听器，将IoC容器载入到Web环境中来，并将其初始化。在建立完这个过程后，IoC容器才能正常工作。而Spring MVC是建立在IOC容器基础之上的，这样才能建立其MVC框架的运行机制，从而响应Web容器传递的Http请求。 Web.xml配置1234567891011121314151617181920212223242526&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-dao.xml,classpath:spring/spring-service.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 在上面的配置中，首先定义了一个Servlet，它是Spring MVC 的DispatcherServlet,在Spring MVC中是一个很重要的类，起着分发请求的作用，同时这个Servlet对应的url为/，意味着接收所有格式的请求地址。init-param中配置了spring mvc的配置文件，在这个文件中定义了mvc相关的bean,同时定义了一个listener，这个监听器是与Web服务器生命周期相关联的，由ContextLoaderListener监听器负责完成IoC容器在Web环境中的启动工作。从上面的配置看到DispatcherServlet，ContextLoaderListener，提供了Web容器中对Spring的接口，也就是说，这些接口与Web容器耦合是通过ServletContext来实现的，这个ServletContext为SpringIoC容器提供了一个宿主环境，在这个宿主环境中，Spring MVC 建立起了一个IoC容器的体系。这个IoC容器体系是通过ContextLoaderListeners的初始化建立的。在建立起IoC容器体系后，把DispatcherServlet作为Sping MVC 处理Web请求的转发器建立起来，从而完成了响应Http请求的准备。 IoC容器在Web环境中的启动过程IoC容器启动的基本过程IoC容器的启动过程就是建立上下文的过程，该上下文与ServletContext相伴而生的，同时也是IoC容器在Web环境中的具体表现之一。由ContextLoaderListener启动的上下文为根上下文，在根上下文的基础上，还有一个WebMVC 相关的上下文用来保存控制器MVC需要的对象，作为根上下文的子上下文，构成一个层次化的上下结构体系，这个上下文体系是由ContextLoader来完成的。 WebApplicationContext接口的继承关系 在这个类继承关系中 , 可以从熟悉的XmlWebAPPlicationContext入手来了解它的接口实现.在接口设计中 , 最后是通过ApplicationContex接口与BeanFactory接口对接的 ,而对于具体的功能实现 , 很多都是封装在其基类AbstractRefreshableWebApplicationContext中 完成的。 同样 , 在源代码中 , 也可以分析出类似的继承关系。 在启动过程中，Spring会使用一个默认的WebApplicationContext的实现作为IoC容器就是XmlApplicationContext,在继承了基本的ApplicationContext功能的基础上，增加了Web环境和对Xml配置处理功能，在XmlApplicationContext的初始化过程中，Web容器中的IoC容器被建立起来，从而在Web容器中建立起整个Spring应用这里加载Bean的方式和之前所说的加载BeanDefinition一样，只不过多了一些读取指定配置文件的applicationContext.xml文件的细节。 为了了解IoC容器在Web容器中的启动原理 , 这里对启动器ContextLoaderListener的实现 进行分析. 这个监听器是启动根IoC容器并把它载入到Web容器的主要 ,也是整个 Spring Web应用加载IoC的第一个地方。 从加载过程可以看到, 首先从Servlet事件中得到 ServletContext, 然后可以读取配置在web.xml中的各个相关的属性值,接着ContextLoader会 实例化WebApplicationContext, 并完成其载入和初始化过程. 这个被初始化的第一个上下文 作为根上下文而存在.这个根上下文载人后, 被绑定到Web应用程序的ServletContext上。 任何需要访问根上下文的应用程序代码都可以从WebApplicationContextUtils类的静态方法中得到 1234567891011121314151617181920212223242526272829303132333435363738public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; // 先判断WebApplicationContext是不是已经存在，已存在则抛出异常 if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123; throw new IllegalStateException(\"Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!\"); &#125; else &#123; Log logger = LogFactory.getLog(ContextLoader.class); servletContext.log(\"Initializing Spring root WebApplicationContext\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Root WebApplicationContext: initialization started\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 没有先创建一个 if (this.context == null) &#123; this.context = this.createWebApplicationContext(servletContext); &#125; // 这里判断有没有parent上下文，如果有则把parent上下文加载出来。 if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext)this.context; if (!cwac.isActive()) &#123; if (cwac.getParent() == null) &#123; ApplicationContext parent = this.loadParentContext(servletContext); cwac.setParent(parent); &#125; this.configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; //将加载完的webapplicationcontext设置到servletContext中保存起来。 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); //... 省略部分代码 &#125; &#125; 创建WebApplicationContext的代码 1234567891011121314151617181920212223242526272829protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123; // 这里判断用什么样的类作为Web 容器中Ioc容器 Class&lt;?&gt; contextClass = this.determineContextClass(sc); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException(\"Custom context class [\" + contextClass.getName() + \"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\"); &#125; else &#123; // 直接实例化要产生的IoC容器 return (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass); &#125; &#125; protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123; String contextClassName = servletContext.getInitParameter(\"contextClass\"); if (contextClassName != null) &#123; try &#123; return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader()); &#125; catch (ClassNotFoundException var4) &#123; throw new ApplicationContextException(\"Failed to load custom context class [\" + contextClassName + \"]\", var4); &#125; &#125; else &#123; contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName()); try &#123; return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader()); &#125; catch (ClassNotFoundException var5) &#123; throw new ApplicationContextException(\"Failed to load default context class [\" + contextClassName + \"]\", var5); &#125; &#125; &#125;","categories":[{"name":"Spring 源码分析","slug":"Spring-源码分析","permalink":"http://blog.vnicers.com/categories/Spring-源码分析/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"Spring 依赖注入源码分析","slug":"Spring 依赖注入源码分析","date":"2014-02-12T16:00:00.000Z","updated":"2017-08-06T07:50:34.000Z","comments":true,"path":"2014/02/13/Spring 依赖注入源码分析/","link":"","permalink":"http://blog.vnicers.com/2014/02/13/Spring 依赖注入源码分析/","excerpt":"","text":"getBean 之前写的Spring IOC 容器这篇文章大致讲了一些IoC容器的初始化过程,主要是IoC容器中建立BeanDefinition的数据映射。但是还没涉及到IoC容器对Bean的依赖关系进行注入，接下来从源码角度分析一下IoC容器是怎样对Bean的依赖关系进行注入的。 首先注意到依赖注入的过程是用户第一次向IoC容器获取Bean时触发的。也就是最基本的BeanFactory接口中的getBean方法，下面从它DefaultListableBeanFactory的基类AbstractBeanFactory入手去看下getBean的实现 通过查看getBean方法的几个重载，正在干活的是doGetBean方法,也就是依赖注入发生的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; final String beanName = transformedBeanName(name); Object bean; // 这里先检查缓存中是否已经有单例对象 // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; // 一些健壮性的代码检查单例对象是否还未完成初始化 if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; // 如果是单例对象，在这里根据sharedInstance直接返回了，这里包含了一些处理sharedInstance是否是 // FactoryBean的逻辑,如果是普通对象直接返回sharedInstance，如果sharedInstance是FactoryBean // 则通过这个FactoryBean来创建一个单例对象返回 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 多例状态的bean如果正在创建过程中抛出异常，避免循环引用 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; //判断BeanDefintion是否存在，顺着BeanFactory链条一直往上递归查找 // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 获取当前Bean的所有依赖Bean，同样是递归调用getBean,直到所有依赖都获取到。 // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; if (isDependent(beanName, dependsOnBean)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dependsOnBean + \"'\"); &#125; registerDependentBean(dependsOnBean, beanName); getBean(dependsOnBean); &#125; &#125; // Create bean instance. if (mbd.isSingleton()) &#123; // 通过调用createBean 方法创建单例Bean,回调函数则是根据不同实现类来处理createBean的逻辑 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 多例Bean的创建 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; // ... 省略一部分代码 &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 对创建的Bean进行类型检查 // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type [\" + ClassUtils.getQualifiedName(requiredType) + \"]\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; // 返回包含了依赖关系的Bean return (T) bean; &#125; createBean重点来说getBean是依赖注入的起点，之后会调用createBean，下面通过createBean源码来了解这个实现过程在AbstractAutowireCapableBeanFactory 中实现了这个createBean，也就是上面的ObjectFactory中getObject回调方法中的createBean，createBean 不但要生成了需要的Bean,还对Bean初始化进行了处理，比如实现了BeanDefinition中的init-method和Bean的后置处理，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // 这里判断需要创建的Bean是否可以实例化，这个类是否可以通过类加载来加载 // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 如果Bean配置了PostProcessor 那么返回一个代理对象 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; //这里调用真正干活的方法doCreateBean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125; 具体创建bean的方法 1234567891011121314151617181920212223242526272829303132333435363738protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. // 这个Wrapper是用来持有创建出来的Bean对象的 BeanWrapper instanceWrapper = null; // 如果是单利则把缓存中的同名的Bean 清除 if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; // 真正创建Bean的地方，由createBeanInstance来完成 if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // ... 省略部分代码 // 对Bean进行初始化，依赖注入往往发生在这里，这个exposedObject在初始化完成以后会返回作为依赖注入完成后的Bean // Initialize the bean instance. Object exposedObject = bean; try &#123; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; // ... 省略部分代码 return exposedObject; &#125; createBeanInstance在上面可以看到与依赖关系特别密切的方法有createBeanInstace和，populateBean，下面分别介绍着两个方法。在createInstance中生成了Bean所包含的Java对象，这个对象的生成有很多不同方式，可以通过工厂方法，也可以通过容器的autowire特性生成，这些生成方式都是通过BeanDefinition来指定的。源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 确保所创建的Bean可以实例化 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); &#125; // 如果BeanDefinition有工厂方法配置，则用工厂方法模式创建对象 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; return instantiateBean(beanName, mbd); &#125; &#125; // 使用构造函数进行实例化 // Need to determine the constructor... Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; return autowireConstructor(beanName, mbd, ctors, args); &#125; // No special handling: simply use no-arg constructor. // 使用默认的实例化策略对Bean进行实例化，也就是使用CGLIB对Bean进行实例化 return instantiateBean(beanName, mbd); &#125; 最后面使用CGLIB对Bean进行实例化。CGLIB是一个常用的字节码生成器类库，他提供了一些API来提供生成和转换Java的字节码功能。在Spring AOP中也使用CGLIB对Java的字节码进行增强。要了解怎样使用CGLIB来生成Bean对象，需要看下SimpleInstantitionStrategy类的源码这个策略是Spring用来生成Bean对象的默认类，它提供了两种实例化Java对象的方法，一种是BeanUtils,通过反射功能来实例化对象，一种是通过CGLIB来生成 populateBean上面个介绍了Bean对象的生成，在Bean对象生成完成以后，怎样把Bean的依赖对象的关系设置好，完成整个依赖注入过程。就是上面提到了populateBean方法，这里代码优点多不贴了。总之是对各种数据类型的依赖进行注入。 参考《Spring 技术内幕-深入理解SPring架构与设计原理第二版》","categories":[{"name":"Spring 源码分析","slug":"Spring-源码分析","permalink":"http://blog.vnicers.com/categories/Spring-源码分析/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"在Bean中操作IoC容器","slug":"在Bean操作IoC容器","date":"2014-02-12T16:00:00.000Z","updated":"2017-08-06T10:32:02.000Z","comments":true,"path":"2014/02/13/在Bean操作IoC容器/","link":"","permalink":"http://blog.vnicers.com/2014/02/13/在Bean操作IoC容器/","excerpt":"","text":"IoC容器管理的Bean一般不需要了解容器的状态和直接使用容器，为了和IoC容器api耦合降到最低。但是在某些情况下，是需要在Bean里面直接对IoC容器进行操作，这个时候，需要在Bean中设定对容器的感知。Spring IoC容器提供了该功能，它是通过特定的aware接口来完成的主要有以下这些: BeanNameAware 可以在Bean中得到它所在的IoC容器中的Bean的示例名称。 BeanFactoryAware 可以在Bean中得到它所在IoC容器，从而直接在Bean中使用IoC容器的服务。 ApplicationContextAware 可以在Bean中得到Bean所在应用上下文，从而直接在Bean中使用应用上下文服务。 MessageSourceAware 在Bean中可以得到消息源 ApplicationEventPublisherAware 在Bean中可以得到应用上下文的事件发布器，从而可以在Bean中发布应用上下文事件 ResourceLoaderAware 在Bean中可以得到ResourceLoader,从而在Bean中使用ResourceLoader加载外部对应的Resource资源","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"Spring IOC 容器","slug":"Spring IOC 容器","date":"2014-02-03T16:00:00.000Z","updated":"2017-08-05T07:15:56.000Z","comments":true,"path":"2014/02/04/Spring IOC 容器/","link":"","permalink":"http://blog.vnicers.com/2014/02/04/Spring IOC 容器/","excerpt":"","text":"IOC容器的设计与实现Spring IOC 容器中有两个主要的容器 实现BeanFactory 接口的简单容器实现，只是实现了容器的基本功能，主要的几个方法如下 其中最主要的是getBean方法，通过指定的名字对在容器中获取Bean containsBean判断容器中是否包含指定名字的bean isSingletion和isPrototype方法分别判断bean是否是单例或者多例的 isTypeMatch 来查询指定名字的Bean 的Class类型是否和特定的Class类型匹配 实现ApplicationContext接口的高级容器实现 扩展了BeanFactory的主要功能，同时支持国际化实现，访问资源的功能，支持应用事件。 BeanFactory和FactoryBean BeanFactory 是一个Factory，也就是IoC容器中的对象工厂 FactoryBean 是一个Bean,在Spring中所有的Bean都是由BeanFactory来管理的，但是对FactoryBean而言，这个Bean不是简单的Bean,而是一个能产生或者修饰对象生成的工厂Bean BeanDefinition 在Spring 提供的基本IoC容器的接口定义和实现的基础上，Spring通过定义BeanDefinition来管理基于Spring的应用中各种对象以及他们之间相互依赖关系，BeanDefinition 抽象了我们队Bean的定义，对IoC容器来说，BeanDefinition就是对依赖反转模式中管理的对象依赖关系中的数据抽象，也是容器实现依赖反转功能的核心数据结构。 IoC容器的初始化各种不同的容器初始化都是在加载完配置文件后调用refresh方法，这个方法标志这IoC容器的正式启动，这个启动包括BeanDefinition的Resource定位，载入和注册三个基本过程 Resource 定位 通过ResourceLoader 对不同形式的Resource进行加载，比如FileSystemResource,ClassPathResource Beandefinition 载入 将用户定义好的Bean表示为IoC容器的内部数据结构就是BeanDefinition，通过这个对象，IoC容器能够方便的对Bean进行管理 IoC容器注册BeanDefinition 通过调用BeanDefinitionRegistry的实现，将载入过程中得到的BeanDefinition向IoC容器中注册，实际上是是添加到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的 这里的IoC容器初始化过程们，一般不包含Bean的依赖注入的实现。在Spring IoC的设计过程中，Bean 定义的载入和依赖注入是两个独立的过程 依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。 IoC容器的依赖注入 依赖注入时序图","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"Spring 基本概念","slug":"Spring 基本概念","date":"2014-01-31T16:00:00.000Z","updated":"2017-08-05T04:01:38.000Z","comments":true,"path":"2014/02/01/Spring 基本概念/","link":"","permalink":"http://blog.vnicers.com/2014/02/01/Spring 基本概念/","excerpt":"","text":"用途使用Spring框架来简化开发，实现程序的解耦，以及使用Spring一些开箱既用的功能，以及对常用框架的一些分装 其中解耦体现在对象的解耦和通用功能的解耦分别是IOC和AOP IOC 控制反转 在不使用IOC容器的情况下，开发者需要自己new 对象，当业务变大之后，new 的对象也就变得非常多，对象之间的依赖关系也就变得很复杂，耦合度过高不好维护，不仅出现在对象和对象之间，也出现在模块与模块之间，各个系统之间。 IOC 就是用来解决对象之间的耦合问题，将原本开发者自己需要new 对象的事情交给IOC第三方 容器来实现，实现对象之间的解耦，模块之间的解耦，系统之间的解耦 比如UserController 这个控制器，依赖UserService,UserService 又依赖UserDAO,UserDAO 依赖一些ORM框架。这里不使用IOC的情况下你直接在UserController中new UserService()是不行的，需要从最底层开始，先初始化ORM框架，然后new DAO层，将ORM框架set到DAO层，然后new Service 层，将DAO层set到Service层，最后将service层set到Controller层。这样开发者需要关心各个层之间的依赖，在使用了IOC容器之后，你在Controller层不用关心Service层里依赖了什么对象。直接使用Service对象，如果service层中的对象不存在，则有IOC容器初始化service中依赖，等等。 将这个整个过程反转过来 就是控制反转，整个依赖对象对象的set过程就是依赖注入。注入的对象都被当做一个普通的Bean存在IOC容器当中， 当然上面依赖注入只是控制反转的一种形式，也可以通过观察者模式，模版方法模式实现反转 AOP 面向切面 将影响多个类的的行为分装到可重用的模块中，将一些公共功能抽离出来，开发者只关注业务相关的内容。，分别开发，在运行时，将切面分装的公共功能横切到业务层中。达到所需要的功能。常用的如事务管理、安全检查、缓存、对象池管理等 AOP的关键在AOP框架创建的代理 代理主要分静态代理和动态代理 静态代理是编译时期通过AOP框架的命令生成AOP代理类，AspectJ 编译时期的增强， 动态代理是在运行时期借助JDK的Proxy或者CGLIB在内存中临时生成AOP的代理类，运行时期的增强 如何选择JDK Proxy 和CGLIB， 如果目标类没有实现接口，则使用CGLIB，如果实现了接口则使用JDKProxy JDK Proxy根据类加载器和接口创建代理类，生成一个目标对象的接口的实现类(InvocationHandler) CGLIB 一个代码生成类库，在运行期生成目标对象的一个子类，子类对父类的各种方法增强(MethodInterceptor)","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.vnicers.com/tags/Spring/"}]},{"title":"存储管理","slug":"存储管理","date":"2014-01-11T16:00:00.000Z","updated":"2017-08-06T07:50:34.000Z","comments":true,"path":"2014/01/12/存储管理/","link":"","permalink":"http://blog.vnicers.com/2014/01/12/存储管理/","excerpt":"","text":"逻辑地址和绝对地址 绝地地址：主存储器以字节为编址单位，容量为n的主存储器中，每个单元有唯一的编号，从0到n-1这个唯一的编号就是主存储器的物理地址。逻辑地址：在多道程序设计地址中，操作系统为了方便用户，就允许每个用户都认为自己的作业程序和数据都是存放在地址是0开始的连续地址空间中。这样用户程序中使用的地址就是逻辑地址。 重定位(地址转换) 为了保证作业的连续执行，必须根据分配给作业的主存空间对作业中的指令和数据的存放地址进行转换，这种把相对地址转化成绝对地址的工作成为重定位或者是地址转换。重定位的方式有静态重定位和动态重定位方式。 ①静态重定位：在装入一个作业时，将一个作业中的指令地址和数据地址全部转换成绝对地址，这种转换工作是在作业开始前集中完成的。在作业执行过程中无需执行地址转换 ②动态重定位：在装入一个作业时，不进行地址转换，而是把作业装到分配的主区域中。在作业的执行过程中，每当执行一条指令时都由硬件的地址转化机构转换成绝对地址，这种方式的地址转换工作是在作业执行时动态完成的。动态重定向由操作系统和硬件的地址转化机相互配合来实现。动态重定向的系统支持程序浮动，而静态重定向不能。 固定分区存储管理的原理 固定分区的意思是指主存空间划分成若干连续区后，这些分区的大小和个数固定不变。固定分区管理利用一张“主存分配表” 来说明各分区的情况。装入和结束作业均通过这个分区表来记录分区的使用变化。 存储保护的目的，如何实现存储保护 为了实现存储保护，处理器设置了一对寄存器，即”下限寄存器“和”上限寄存器“，当一个已经装入主存储器的作业得到处理器运行时，进程调度应记录当前运行作业所在的分区号，且把该分区的下限地址和上线地址分别送入下限寄存器和上线寄存器，处理器执行作业时，对每条指令中的地址都要核对，满足下限地址≤绝对地址≤上限地址，如果不成立，则为了防止破坏其他分区的信息，硬件产生地址越界中断事件，停止该指令，达到存储保护的目的。 提高主存空间的利用率的方法①分区按照大小顺序排列，这样能使作业总是先满足要求最小分区。 ②按照经常出现的作业大小和频率划分分区 ③按照作业对主存空间的需求量排成多个队列，规定队列与分区的对应关系。也就是多大的作业只能放在多大的分区里面，就算有更大的分区空着，也不许进入。 主存的分配与回收 在系统初始化时，主存除了操作系统所占部分外，整个用户区是一个大的空闲区，可以按照作业需要的空间大小顺序分配空闲空间直到不够为止。当作业结束时，它所占用的分区被回收。这个空闲区又可以根据新作业的大小重新由于分配，所以主存中已占分区和空闲区的数目的大小是在 变化的。可以在两张已分配表和空闲区表来记录和管理。 常用的分配算法最先适配分配算法：简单的说，就是在分区表中顺序查找，找到够大的空闲区分配，但是这样的分配算可能形成许多不连续的空闲区，造成许多碎片，使空间使用率降低。 最优适应分配算法：这种算法总是挑选一个能满足作业要求的最小空闲区，但是这种算法肯能形成一些极小的空闲区，以致装入大作业时无法使用，会影响主存的使用率。 最坏适应分配算法：这种算法和上面的算法刚好相反，它总是挑一个最大的空闲区分给作业使用，使剩下的空间不至于太小。 地址转换和存储保护 采用可变分区管理时，一般采用动态重定位方式装入作业，也就是每读一条指令，都要变化一次地址，变换要靠硬件支持，主要是两个寄存器：基址寄存器和限长寄存器，限长寄存器存放作业所占分区的长度，基址寄存器则存放作业所占分区的起始位置，这两个值确定了一个分区的位置和大小。转换时根据逻辑地址与限长地址比较，如果没有超过，这个值，表示访问地址合法，再加上基址寄存器中的值，就得到了绝对地址，否则形成”地址越界“的中断，达到存储保护的目的。对于共享程序，则硬件提供两组限长寄存器和基址寄存器，访问时对访问共享区和作业的地址分别进行转换。 作业的移动 移动技术要”移动”的是主存空间中的作业，把某个作业移动到另一处的主存空间去（磁盘处理中应用的也是类似的移动技术），这样最大的好处就是合并一些空闲区。但是移动会增加系统的开销，所以尽量少移动，如果作业正在执行的过程中，正等待外围设备传输信息，就不能移动。 虚拟存储器 虚拟存储器为了扩大主存容量而采取的一种设计手段，它利用作业在只装入部分信息时可以执行的特点，和程序执行中表现出来的的局部特性，借助于大容量的辅助存储器实现小主存空间容纳大逻辑地址空间的作业。 虚拟存储器的实现原理 首先把作业信息保留在磁盘上，当作业请求装入时，只将其中一部分装入主存，作业执行中，若要访问信息不再主存中，则再设法将这些信息装入主存。 分页式虚拟存储器的实现 页式虚拟存储管理器是在页式存储管理的基础上实现的，首先把作业信息作为副本存放到磁盘上，作业执行时，将作业的部分信息装入主存储器，作业执行时，若所访问的页面已经在主存中，则进行地址转换，得到绝对地址，否则产生“缺页中断”，由操作系统将所缺的页面加载到主存。 常见的页面调度算法 当主页中无空闲块时，为了装入一个页面，就必须按照某种算法将主存中的某个页面调出，调入所需装入的页面，这就是页面调度，常用的算法有：先进先出算法(FIFO)，最近最久未使用算法(LRU)，和最近最不常用的调度算法(LFU)。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.vnicers.com/tags/操作系统/"}]},{"title":"处理器管理","slug":"处理器管理","date":"2014-01-10T16:00:00.000Z","updated":"2017-08-06T07:50:34.000Z","comments":true,"path":"2014/01/11/处理器管理/","link":"","permalink":"http://blog.vnicers.com/2014/01/11/处理器管理/","excerpt":"","text":"进程控制块的主要结构 进程控制块 多道程序设计 让多个计算问题同时装入一个计算机系统的主存储器并行执行，这种设计技术称为多道程序设计，这种计算机系统称为多道程序设计系统或简称多道系统 多道程序设计怎样提高系统效率，使用多道程序一定会提高系统效率吗 通过增加并行执行的程序道数，减少处理器的空闲时间，提高处理器的使用率，从而提高单位时间内的算题量； 利用和发挥硬件中各种资源的并行工作能力，使用多道程序不一定会提高系统效率，因为主存器的空间大小，限制了可同时装入的程序数量，其次外围设备的数量也是限制条件，第三多个资源同时使用同一个资源的情况时有发生，在产生系统竞争时，可能发生等待，有等待则会影响系统效率。 进程的基本状态和变化关系 进程在执行的过程中不同的时刻的状态可以分为三种基本状态： 等待态：等待某个事件的完成，就绪态：等待系统分配处理器以便运行，运行态：占用处理器正在运行。 变化关系如下： ①运行态--&gt;等待态,等待外设，主存等资源分配或等待人工干预而引起 ②等待态--&gt;运行态，表示等待的条件已经满足，只要分配到处理器就可以运行 ③运行态--&gt;就绪态，不是由于自身原因，而是由外界原因使运行态的进程让出处理器，例如，时间片用完，有更高优先级的进程来抢占处理器。 ④就绪态--&gt;运行态，系统按照某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态 进程队列基本概念 在多道程序设计的系统中往往会同时创建多个进程，在单处理器情况下，每次只能让一个进程运行，其他的进程处于就绪状态或者等待状态。为了便于管理，经常把处在相同状态的进程链在一起，称为进程队列 UNIX的进程组成，状态及转换 在UNIX系统中进程由三部分组成：进程控制块，正文段，数据段。UNIX进程在执行过程中由于各种原因使其状态不断发生变化，且当内存空间不够时，可以把一些进程换出到磁盘上，需要时又可以把进程换进内存，进程的状态有运行态，就绪态，睡眠态，创建态，僵死状态。 线程的中断优先级和中断屏蔽 中断优先级是硬件设计时确定的。中断装置按照预定的顺序来响应同时出现的中断事件，这个预定的事件称为中断优先级，中断优先级是按照中断事件的重要性和紧迫程度来确定的，是由硬件设计时确定下来的，一般情况下，优先级由高到低的顺序依次为：硬件故障中断，自愿中断，程序性中断，外部中断和输入输出中断。 中断屏蔽的作用，当中断装置响应了某个中断后，中断处理程序在处理中断时，中断装置可能去响应另一个中断事件，=。因此会出现优先级低的中断事件打断优先级高的中断事件，，使得中断事件的处理顺序与响应顺序不一致，而且会形成多重嵌套处理，使多现场保护，程序返回等工作变得复杂。，中断屏蔽技术是为了解决上述问题而提出的在一个中断处理程序没有结束之前不响应其他中断事件。于是当中断装置检查到有中断事件后，还要查看当前PSW的中断屏蔽标志，如果没有屏蔽标志则响应该中断，否则暂时不响应该中断，待屏蔽标志消除后再响应，自愿中断是不能屏蔽的。 进程调度 按照选定的进程调度算法从就绪队列中选择一个进程，让它占用处理器。 进程调度算法的几个准则 提高处理器的使用率，增大吞吐量，减少等待时间，缩短响应时间 进程调度的常用算法 先来先服务，最高优先级，时间片轮询，和分级调度算法。 ①先来先服务算法，该算法按照进程进入就绪队列的先后次序来选择可以占用该处理器进程 ②最高优先级调度算法，对每个进程确定一个优先级，该算法总是让优先级高的进程先使用处理器。对具有相同优先级的进程，再采用先来先服务的算法分配处理器。系统常以任务的紧迫性和系统效率等因素确定进程的优先级，进程的优先级可以固定，也可以随进程的执行过程而发生变化。 ③时间片轮询调度发，把规定的进程一次占用处理器的最长时间称为时间片。时间片轮转调度算法让就绪进程按照就绪的先后次序排成队列，每次总选择该队列的第一个进程占用处理器，但规定只能使用一个时间片，如果该进程尚未完成则放到就绪队列尾，各个进程就这样轮转运行，时间片轮转算法常用于分时操作系统。 ④分级调度算法，由系统设置多个就绪队列，每个就绪队列中的进程按照时间片轮训占用处理器。这就是分级调度算法。 进程的切换 进程调度从就绪队列中另选一个进程占用处理器，使一个进程让出处理器，由另一个进程占用处理器的过程称为进程切换。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.vnicers.com/tags/操作系统/"}]},{"title":"计算机系统结构","slug":"计算机系统结构","date":"2014-01-08T16:00:00.000Z","updated":"2017-08-06T07:50:34.000Z","comments":true,"path":"2014/01/09/计算机系统结构/","link":"","permalink":"http://blog.vnicers.com/2014/01/09/计算机系统结构/","excerpt":"","text":"什么情况下操作系统程序会占用处理器运行 计算机系统启动后，操作系统总是等待某个中断发生，每当发生一个中断事件，就会触发操作系统工作，操作系统的一次工作结束后又主动让出处理器让其他程序运行。 允许多道程序同时执行的硬件基础是什么 中断系统和通道技术 操作系统怎样让多个程序同时执行 处理器在任何时刻只能被一个程序占用，通过中断装置，系统中若干程序可以交替的占用处理器，形成多个程序同时执行的状态，硬件具有处理器和外围设备并行工作能力，各个外围设备也可以并行工作，利用硬件的这种并行工作能力，操作系统允许多个程序同时执行，在同一时刻，分别使用不同的资源 为什么把启动IO等指令定义为特权指令 一个程序可以在其它程序等待外围设备传递信息时占用处理器，在执行任务过程中，如果其他程序也使用启动指令去启动一台正在工作的外围设备就会造成冲突，为了保证输入输出的完整性把启动IO这类可能影响系统安全的指令定义为特权指令。 怎样限制用户程序中使用特权指令 处理器设置了管态和目态两种工作方式，在管态下，处理器可以执行包括特权指令内的一切指令，在目态下，处理器不能执行特权指令，操作系统在管态下工作，用户程序在目态下工作，如果处理器在目态下取到了特权指令则拒绝该指令，并产生非法操作事件经过中断装置和操作系统通知用户修改。 操作系统和硬件如何配合来实现存储保护 存储保护随着主存储器的管理方式不同实现的管理保护方法也不同，在连续分配空间的存储系统中，硬件中设置了两个寄存器来限定用户程序执行中可以访问的内存范围，分别是基址寄存器和限长寄存器，程序执行时，系统对每一个访问内存的地址进行核对满足访问地址大于等于基址寄存器值并且小于等于限长寄存器的值则允许访问，否则不允许访问。这样保证该区域以外的信息不受破坏。 为什么要研究操作系统的结构 操作系统是一种程序量大且复杂的系统软件，设计一个操作系统需要大量的人力和较长的时间，为了保证操作系统能够正确而高效的工作，程序的结构又是影响程序质量的内在因素，因此我们有必要对操作系统结构进行研究。 应该从哪些方面考虑操作系统的结构设计 正确性，一个良好的操作系统不仅能保证正确性，而且易于验证其正确性。 高效性，核心程序是影响程序运行效率的关键，应该遵循少而精的选择，使处理器及有效又灵活。 可维护性，方便维护和后期修改 可移植性，在结构设计时，尽量减少与硬件直接有关的程序量，并将其独立封装 操作系统采用层次结构有什么优点 层次结构的最大特点是把整体问题结构化，一个大型复杂的操作系统被分解成若干单向依赖的的层次，由各层次的正确性来保证整个操作系统的正确性，采用层次结构不仅结构清晰，而且调试方便，有利于功能的增删改。 用户怎样使用操作系统提供的接口 操作系统为用户提供两种类型的使用接口，一种是操作员级的接口，一种是程序员级的接口以便用户与操作系统建立联系，操作员级别的接口是一组操作控制指令，他们供用户提出如何控制作业执行的要求，程序员级别的接口是一组系统功能调用，他们为用户程序提供服务功能 操作系统为什么要提供”系统调用“ 系统调用是操作系统为用户程序提供的一种服务界面，或者说是操作系统保证程序程序设计语言能够正常工作的一种支持，在源程序一级，用户程序设计语言描述算题任务的逻辑要求，，如读文件，写文件，请求主资源等，这些要求的实现只能通过操作系统的系统调用才能完成，其中有些要求还必须执行硬件的特权指令（I/O）才能达到目的。 UNIX系统的层次结构有什么特点 UNIX的层次结构主要包括内核层和外壳层，内核层包括系统调用，存储管理，文件管理，设备管理，进程管理， 外壳层包括shell，编译程序，解释程序，实用程序吗，系统库。 UNIX为用户提供怎样的使用接口 操作系统面向用户提供的两类使用接口：操作控制命令和系统功能调用。UNIX提供的操作控制命令被称为Shell命令。若干条shell命令组成一个shell文件 用户程序怎样请求UNIX的系统功能调用为其服务？ 用户程序是使用“访管命令”来请求系统调用的，对不同的系统来说，访管命令的形式是不同的。在UNIX系统中，规定用户程序使用“trap”命令来请求系统调用。 trap处理程序的主要职责 trap处理子程序根据trap命令中的系统调用编号查系统调用程序入口表，得到该系统调用所带的参数个数和相应的处理程序入口地址。然后，然后把参数传到内核的系统工作区，再按处理程序入口地址转向该系统调用的处理程序执行。 UNIX为什么能够允许同一个用户同时执行两个以上的任务 如果一个程序的运行时间较长，且该程序运行时不再需要在终端输入任何信息，那么用户可以要求UNIX将这个应用转入后台不再加以监视，，UNIX规定只要在请求后台执行命令末尾输入字符&amp;，命令在执行时，就把实现这条命令的程序转入到后台。，不等该程序执行完就返回前台，且显示可以输入新的命令提示，如果输入了新的命令，那么实现这条命令的程序就与转入后台的程序同时执行。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.vnicers.com/tags/操作系统/"}]},{"title":"网络规划与设计","slug":"09，网络规划与设计","date":"2014-01-07T16:00:00.000Z","updated":"2017-08-04T11:25:17.000Z","comments":true,"path":"2014/01/08/09，网络规划与设计/","link":"","permalink":"http://blog.vnicers.com/2014/01/08/09，网络规划与设计/","excerpt":"","text":"说明网络设计的过程以及在各个步骤中应该要注意的事项 需求分析 可行性分析 注意网络环境，设备配置，用户的功能要求，系统目标，技术支持和效益分析 网络规划 对需求分析的技术论证，网络的分布，网络的基本设备和类型，网络的基本规模，基本功能和服务项目的总规划 网络系统整体设计 网络拓扑结构的设计，网络组网方案的确定，软硬件设施的选择，结构化布线，网络主数据库系统的选择和形成网络总体说明书等内容 选择网络拓扑结构时应该注意的几个问题 主干网拓扑结构的可靠性,时延，吞吐量，和网络费用多加考虑 本地网络拓扑结构交换机的选址，客户机场地的分配和终端的布局 经济性 灵活性 可靠性 什么叫综合布线，它有哪些特点 综合布线系统是通用的信息传输系统，通常对建筑物内各种系统所需的传输线进行统一编制，布置好人连接，形成完整统一和高效兼容的建筑物布线系统。 特点 结构清晰，便于管理和维护 材料先进和统一，适应今后的发展需要 灵活性强，适应各种不同的需求 便于扩充，即节约费用又提高可靠性 综合布线系统的各个组成部分 工作区子系统 水平干线子系统 管理间子系统 垂直干线子系统 设备间子系统 建筑群子系统","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"Internet技术","slug":"06，Internet技术","date":"2014-01-04T16:00:00.000Z","updated":"2017-08-04T11:25:24.000Z","comments":true,"path":"2014/01/05/06，Internet技术/","link":"","permalink":"http://blog.vnicers.com/2014/01/05/06，Internet技术/","excerpt":"","text":"Internet 的功能体现在哪些方面 从网络技术方面来看Internet 是利用TCP/IP协议把各个国家部门，和机构的内部网络连接起来的超级数据通信网络 从提供信息资源的角度来看Internet是集各个部门领域内，各种信息资源为一体的超级资源网络 从网络管理的角度来看，Internet是一个不受政府或者某个组织管理控制的 设置域名的原因是什么 对于一般用户来书，要记住IP地址比较难，为了向用户提供一种直观明了的主机识别符号，使用域名相对于IP地址来说更容易让人们识别。 国际顶级域名有哪些分为几类，我国的域名体系结构是什么样的 组织顶级域名 .com 商业组织 .edu 教育组织 .gov 政府部门 .mil 军事部门 .net 网络支持中心 .org 其他组织 .int 国际组织 物理顶级域名有各个国家的简称 我国的域名体系结构中国最上层是cn域名然后下面是各种组织域名 域名的解析过程 当发起一个请求时，现在本机缓存中查找，如果没有找到，则方法送给本地DNS服务器查找 本地DNS服务器找到后则在该服务器所管理的区域找到该记录进行解析，如果没有找到对应的信息，则在服务器本地缓存中查找 本地服务器中找不到对应的信息则将请求发送给高一级的域名服务器中查找，一次类推知道根域名服务器 DNS服务器递归查询的结果返回给客户端 客户机利用返回的IP地址进行请求 Internet接入方式有哪些 电话线拨号接入 ISDN接入 ADSL接入 光纤接入 简述ADSL的原理和特点 ADSL是一种非对称数字用户线路，他是一种上下行不对称的高速数据调制技术，以传统铜线为传输介质，采用数字调制技术和信号处理，在普通电话线传送电话业务的同时还可以传送告诉宽带。 特点 提供各种多媒体服务 使用方便 静态ip地址 HFC的原理和特点 HFC通常由光纤干线、同轴电缆支线和用户配线网络三部分组成，从有线电视台出来的节目信号先变成光信号在干线上传输；到用户区域后把光信号转换成电信号，经分配器分配后通过同轴电缆送到用户 光纤接入有哪些方式 FTTC光纤到路边 FTTP光纤到大楼 FTTH光纤到户 Intranet的定义和特点，有哪些功能，主要用于什么服务 Intranet 为内联网，表示这是一组在特点机构内使用的互联网络，采用的是Internet上早已经成熟的标准，使机构内涉及多种平台的网络应用开发不必拘泥于传统的客户/服务器技术 特点 开放性和扩展性 通用性 简易性和经济性 安全性 主要用于的服务 信息共享与通信 数据库与工作流应用 以业务流程为中心的应用 Intranet的体系结构 Intranet通常是指一组沿用Intraent,采用客户端/服务器结构的内部网络，服务器端是一组Web服务器，用以存放Intranet上共享的HTML标准格式信息以及应用，客户端则配置浏览器，用户以浏览器发送请求，Web服务器讲结果返回给客户端","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"网络操作系统","slug":"07，网络操作系统","date":"2014-01-04T16:00:00.000Z","updated":"2017-08-04T11:24:02.000Z","comments":true,"path":"2014/01/05/07，网络操作系统/","link":"","permalink":"http://blog.vnicers.com/2014/01/05/07，网络操作系统/","excerpt":"","text":"网络操作系统具有哪些特征和基本功能 特征： 网络操作系统是使联网计算机能够方便的有效的共享网络资源，为网络用户提供各种服务软件与协议的集合 基本功能：屏蔽本地资源与网络资源的差异性，为用户提供基本网络服务功能，完成网络共享资源的管理，并提供网络系统的安全性服务 对等结构网络操作系统和非对等网络操作系统的优缺点 对等网络操作系统 优点:结构简单，网路中任何节点都能直接通信 缺点:每台联网节点既要完成工作站的功能，又要完成服务器的功能，加重了联网计算机的负荷，信息处理能力比较低，规模较小 非对等网络操作系统 优点:分工明确 缺点:使用使用共享硬盘是操作不方便，系统效率差，安全性差 典型网络操作系统的特点及其适用环境 Windows 特点:对硬件要求教高，稳定性不好， 适用: 个人用户，和中低档服务器中 NetWare 特点:对网络硬件要求较低，对无盘工作站和游戏的支持较好 适用:设备比较落后的中小型企业，学校的青睐 Unix 特点:稳定性和安全性较好 ,对初级用户不适用 适用:大型的网站和大型的企业 Linux 特点:源码开放，免费，安全性和稳定性较好 适用:中高档服务器 活动目录的概念 让用户通过目录很容易的找到所需要的数据，以阶梯的结构将对象容器，组织单位结合在一起将其存储到活动目录的数据库中 Unix系统的组成以及层次结构 组成 核心程序 负责调度任务和管理数据存储 外围程序 接受并解释用户命令 实用性程序 完成各种系统维护功能 应用程序 在Unix系统中开发的程序 层次 内核 外壳 Unix系统和Linux的联系和区别 Linux系统虽然与Unix相似，但是并不是Unix操作系统的变种 Unix所有工具和外壳都能运行在Linux上 Linux具备Unix操作系统的基本特征 Linux系统的组成和特点 组成 内核 Shell 文件结构 特点 开发源代码 安装配置简单 支持多用户 不限制应用程序的可用内存","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"局域网技术","slug":"04，局域网技术","date":"2014-01-03T16:00:00.000Z","updated":"2017-08-04T11:22:01.000Z","comments":true,"path":"2014/01/04/04，局域网技术/","link":"","permalink":"http://blog.vnicers.com/2014/01/04/04，局域网技术/","excerpt":"","text":"什么是局域网,局域网有哪些特点 局域网是将较小地理区域的各种数据通信设备链接在一起的通信网络 特点： 覆盖的地理位置范围较小 数据传输的效率较高 具有较低的延迟和误码率 局域网的经营权和管理权归某个单位所有 便于安装和维护以及扩展 方便共享 提高了系统的可靠性和，可用性 局域网有哪些分类 从媒体访问角度分为 共享介质局域网和交换局域网 从传输介质上分为有线局域网和无线局域网 MAC和LLC层各自完成数据链路层的哪些功能 MAC :主要制定用于管理和分配信道的协议规范 LLC :在MAC层提供的介质访问控制和物理层提供的比特服务基础上将不可靠的信道处理成可靠的信道 常用的介质访问控制方法有哪些 带有冲突检测的载波监听多路访问 令牌环 令牌总线 简述载波监听多路访问/冲突检测法（CSMA/CD）的工作原理 采用随机访问和竞争技术，将所有的设备链接到一条物理信道上，它的发送流程采用先听后发，边听边发，冲突停止，随机延迟后重发 简述令牌访问控制（Token-Ring）的工作原理 在令牌环中，节点通过环接口，连接成物理环型，当环工作正常是，令牌总是沿着物理环单向逐站传送，传送节点和节点在换中的顺序相同 简述令牌总线访问控制（Token-Bus）的工作原理 任何一个节点在取得令牌后才能使用共享总线发送数据 以太网有哪几种组网方式，各有什么特点 传统以太网，特点是传输速率为10Mb/s,共享介质，同轴电缆，总线型网络拓扑 快速以太网，特点是传输速率为100Mb/s，结构简单，实用，成本低，易于普及 千兆以太网，特点是传输速率为1000Mb/s，简易型，网络可靠 万兆以太网，特点是传输速率为10000Mb/s 以上组网方式都是单一集线器结构 为什么需要虚拟局域网，有哪几种实现方式，各自的工作原理是什么 虚拟局域网打破了地理位置的制约，在不改动网络物理连接的情况下可以将工作站和工作子网移动，工作站组成逻辑工作组或虚拟子网，提供系统的运作性能，均衡网络流量，合理运用硬件和信息资源，同时也减轻了网络管理和维护工作。 实现方式： 静态VLAN 将以太网网交换机上的一些端口划分成一个VLAN,这些端口一直保持这种配置关系知道人工再次改变它 动态VLAN 交换机上的VLAN端口是动态分配的，以MAC地址为基础分配VLAN,网络管理员可以进行配置以指定哪些MAC地址的计算机属于某一个VLAN,不管这些计算机连接到那个交换机的端口。只要mac地址不变，，它仍将属于原VLAN的成员 虚拟局域网有哪些优点 减少网络管理开销 控制广播活动 提供较好的网络安全性 利用现有的集线器节省开支","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"广域网技术","slug":"05，广域网技术","date":"2014-01-03T16:00:00.000Z","updated":"2017-08-04T11:22:48.000Z","comments":true,"path":"2014/01/04/05，广域网技术/","link":"","permalink":"http://blog.vnicers.com/2014/01/04/05，广域网技术/","excerpt":"","text":"广域网的结构和特点 特点 运行地域超过局域网的数据通信网络 使用各种类型的串行连接起来接入广泛地理领域的宽带 连接分布在广泛地理领域内的设备 使用电信运营商服务 广域网的类型和各自的特点 线路交换网 面向连接的网络。在数据需要发送时，发送设备必须建立并保持一个连接，知道数据被发送 专用线路网 连个点之间的一个安全永久的信道，不需要经过任何连接和拨号 分组交换网 一种以分组为基本数据单元进行数据交换的网络 帧中继网络的特点，组成和特点 帧中继在传送数据时，只检查包的包头中的目的地址，就立即传送此包 帧中继只处理OSI的最低两层，是一个面向帧的通信协议、 帧中继提供永久性虚电路和交换虚电路 帧中继可以支持很高的传输速率 什么是ISDN,它给用户提供了哪几种业务 ISDN 综合业务数字为，是对电话系统重新设计的，提供适合于声音和非声音的综合通信系统来替代模拟电话系统 提供的主要业务如下 实时性服务 多媒体传输 多媒体检索 DDN的结构和接入方式 DDN有数字通道，DDN节点，网络控制和用户环路组成 网络互联有哪几种形式 将不同的网络用互联设备链接在一起形成一个范围更大的网络 将一个原本很大的网络划分为几个子网或者网段 常用的网络互联设备，分别工作在OSi模型上的哪一层 中继器 物理层 集线器 物理层 网桥 数据链路层 交换机 物理层 路由器 网络层 网关 传输层以上 网桥的工作原理和分类 网桥可以过滤通信量，站点A发送数据帧给站点B，网桥侦听到这个帧，根据目标MAC地址判断两个站点在同一个网段上，就阻止数据包进入其他的网段，起到过滤通信量的作用，网桥还可以根据MAC地址转发帧 分类 基于802.1的透明网桥和生成树网桥 基于802.5的标准的源路由选择网桥 路由器的主要功能和原理 功能：路由选择和数据转发，在网络层提供多个独立子网间连接服务的一种存储转发设备，用路由器连接的网络可以使用在数据链路层和物理层协议完全不同的网络互联中 原理 路由器通过路由选择算法建立一个路由表，表中包含着目的地址和下一跳路由器地址等多种路由信息，根据路由表提供的吓一跳路由地址，将数据包转发给下一跳路由器，通过一级级的方式吧数据包转发到一下跳路由器最终把数据传达到目的地","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"计算机网络体系结构","slug":"03，计算机网络体系结构","date":"2014-01-02T16:00:00.000Z","updated":"2017-08-04T11:21:25.000Z","comments":true,"path":"2014/01/03/03，计算机网络体系结构/","link":"","permalink":"http://blog.vnicers.com/2014/01/03/03，计算机网络体系结构/","excerpt":"","text":"什么是网络协议，由哪三个要素组成 对等实体间实交换数据或通信时所必须遵守的规则或标准的集合叫做协议， 由以下三个要素组成： 语义 代表“讲什么” 用于协调与差错处理的控制信息 语法 若干语法组合表达完整内容所遵循的格式，用于数据及控制信息的格式，编码及信号电平 定时 规定事件的执行顺序 涉及速度匹配与排序 什么是计算机网络体系结构 引入分层模型后，将计算机系统中各层中的协议以及层次之间的集合称之为网络体系结构 OSI 七层模型结构 及主要功能 应用层：应用进程访问网络服务的窗口，直接为网络用户或应用程序提供各种网络服务。 表示层：表示通信设备的互操作性，使得两台内部结构不同的计算机能实现通信 会话层：在两个节点间建立维护和释放面向用户的连接，并对会话进行管理和控制。保证会话数据的可靠传输 传输层：负责端到端节点数据传输和控制功能的层，为会话层屏蔽了传输层以下数据通信的细节 网络层：在通信子网中选择合适线路，使发送端传输层传输的数据能够通过所选择的路径到达目的端 数据链路层：在传输过程中提供确认，差错控制，流量控制，通过加强物理层传输原始比特的功能提供可靠传输 物理层：传输原始比特流（解决传输介质，信道类型，数据与信号之间的转换信号的衰减问题） TCP/IP协议体系结构 应用层：用于提供网络服务，比如文件传输，远程登录，域名服务和简单网络管理 传输层：TCP和UDP提供应用间的可靠传输和不可靠传输 网际层：处理传输层的分组，将分组形成数据包，并进行路径选择，最终将数据包，从源主机发送到目的地主机 网络接口层 IP和TCP，UDP的功能 IP : 网际协议IP，主要功能是处理来自传输层的分组，将分组形成数据包，并进行路径选择，最终将数据包，从源主机发送到目的地主机 TCP：用户数据包协议，提供可靠传输 UDP: 用户数据包协议，提供不可靠传输 SLIP和PPP的含义及作用 SLIP使用串行线路连接主机与网络或者连接 PPP 点对点协议 ARP 和 RARP 的作用 ARP 协议实现IP地址到物理地址的映射 RARP协议实现物理地址到IP地址的映射 什么是IP地址，IP地址由什么构成 在因特网中为了使众多的主机能够相互识别，我们通常要给每一台主机分配一个唯一的IP地址 构成：IP地址是一个32位的二进制数据，由类别，网络号，和主机号三个部分组成 IP地址有几类，如何区分的 A类：A类地址网络号占1个字节，主机号占3个字节，第1个字节的最高位是0 B类：网络号和主机号各占两个字节，并且第1个字节的最高位是10 C类：网络号占3个字节，主机号占1个字节，并且第1个字节的最高3位是110 D类：用于多播，同时把数据发送给一组主机 E类：预留，用于实验目的 11.子网掩码的作用，如何划分子网 作用：可以指出一个IP地址中的哪些位对于网络地址，哪些位对于主机地址 如何划分:将地址的主机号部分进一步的分成网络号和主机号两个部分","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"计算机网络基本原理","slug":"02，计算机网络基本原理","date":"2014-01-01T16:00:00.000Z","updated":"2017-08-04T11:20:48.000Z","comments":true,"path":"2014/01/02/02，计算机网络基本原理/","link":"","permalink":"http://blog.vnicers.com/2014/01/02/02，计算机网络基本原理/","excerpt":"","text":"数据，信息，和信号的概念，区别和联系 信息：代表有用的知识或者消息 数据：运送信息的实体，是信息的表达方式，可以是数字，文字，声音和，图形和图像 信号：数据在传输过程中的电磁波的表示形式 区别和联系：计算机网络通信目的是为了交换信息，而信息以不同形式的数据表示，统一以二进制表示然后转化为物理信号以电磁波形式传输 从不同的角度区分数据通信方式分为哪些不同的类型 按照传输信号的不同可以分为模拟信号传输和数字信号传输 按照同步作用的不同可以分为异步传输和同步传输 按照数据传输方向的不同可以分为单工通信和半双工通信以及全双工通信 按照物理信道的连接方式不同分为点对点连接，多点连接，集中式连接 按照数据的传输方式不同可以分为并行通信和串行通信 模拟传输和数字传输各有什么优缺点，为什么数字传输是今后发展的方向 模拟传输 优点：信道的利用率较高 缺点：传输过程中信号会衰减，会受到噪声干扰，且信号放大时噪声也会放大 数字传输 优点：传输不失真，误码率低，能被复用并能有效的利用设备 缺点：要求的频带要比模拟传输宽很多，信道利用率较低数字化是今后通信的发展是因为数字传输在以后发展过程中传输宽带越来越大 串行通信和并行通信各有哪些特点，各用在哪些场合？ 并行通信可以同时同时发送多个数据位，接收设备可以同时接收这些数据，无需做任何转换尅直接使用。多用在印制电路板实现的数据总线，连接软盘驱动器的扁平带状电缆，连接计算机设备的圆形多芯屏蔽电缆 串行通信中需要将数据由并串转换硬件转换成串行方式，再逐位经传输线到达接收站的设备中，并在接收端将数据从串行方式重新转化为并行方式多用在远程通信 什么是单工，半双工，全双工通信，他们分别在哪些场合下使用 单工通信只能在一个方向上发送数据，发送方不能接收信息，接收方不能发送信息，多用在无线电广播和电视广播 半双工通信双方都可以交替发送和接收信息，但是不能同时发送和接收信息，一段时间内通信的全部带宽都用在一个方向上的信息传递，多用在航空航海无线电以及对讲机 全双工通信发送方和接收方都能同时发送消息和接收消息，多用在电话和手机 什么是异步传输和同步传输，他们的主要区别是什么 异步就是把各个字符分开传输，字符与字符之间插入同步信息，这种方式叫做起止方式 同步传输在发送数据前，先发送一个同步字符串SYN,接收方只要检测到两个以上SYN字符确认已进入同步状态，准备接受数据，随后双方以同一频率工作，直到传送完指示数据结束控制符为止 区别：异步传输相比同步不适合传输大数据块，同步传输在短距离高速数据传输中更有效 什么是波特率，数据速率和信道容量 波特率又叫调制速率或码元速率他是数字信号经过调制后的传输速率表示每秒传输的信号单元，即调制后的模拟电信号每秒钟变化次数 数据速率是指通信系统单位内传输的二进制代码的位数 信道容量是指信道允许的最大数据传输率是描述信道的主要技术指标之一 什么是误码率，如何减小误码率 误码率是衡量通信系统在正常工作情况下传输可靠的标准。误码率是指二进制码元在传输过程中被传错的概率 纠错译码技术和有效的信源编码技术和信道差错控制编码技术都可以减少传输误码率，减少误码率就要以牺牲有效性为代价，码元传输速率就会降低。 为什么通信中采用多路复用 在计算机网络中，传输线路的成本在整个系统中占相当大的比例，为了提高传输线路的利用率。采用多个数据信道何用一条传输线。 概述频分复用，时分复用和波分复用的原理 频分多路复用是将具有一定带宽的信道分割为若干个较小频带的子信道，每个子信道供一个用户使用，达到同时传送不同频率的信号 时分多路复用是将物理线路按照时间分成多个时间片，没个时间片称作一帧，再分为若干时隙，轮换的为多个信号使用，每一个时隙由一个信号占用 光波分多路复用技术是在一根光纤中能够同时传播多个广播信号的技术，在发送端将不同波长的信号组合起来，复用到一根光纤上，在接收端又将组合的光信号分开，并送入不同的终端 报文交换与分组交换的差别是什么 报文交换属于存储转发交换方式，不需要交换网为通信双方预先建立一条专用数据通道，在这种交换网中存在大容量存储设备的计算机，在传输上，任何时刻一份报文只在一条节点到节点间的点到点链路传输，每个链路的传输过程中都对报文的可靠性负责 分组交换中把进网的任何一个分组都当做单独的小报文来处理，而不管他是属于哪个报文的分组，这种单独处理和传输单元的小报文或分组称为数据报，这种分组价换方式称为数据传输分组交换方式 数据报分组交换与虚线路分组交换有什么区别-数据报分组交换没有呼叫建立过程，到达目的站的顺序与发送时间的顺序肯能不一致，而虚线路方式必须通过虚呼叫建立一条虚拟路，每个分组不需要携带完整的地址信息，只需要带上虚线路的号码标志，不需要选择路径，每个分组均沿虚线路传送，这些分组到达目的地站的顺序与发送时的顺序完全一致。 双绞线，同轴电缆，和光缆三种传输介质的特性 双绞线由两根相互绝缘的导线绞合均匀的螺纹装，用于模拟传输和数字传输，通信距离一般几千米到十几千米，主要用于点对点连接 同轴电缆由内导体铜质芯线，绝缘层，网状编织的外导体屏蔽层以及保护塑料组成，具有很好抗干扰性，被广泛用于高速率的数据传输 光缆由光导纤维电缆组成，网络传输介质中性能最好广泛应用的一种，以金属导体为核心传输介质，只能用光脉冲形成的数字信号通信，由于可见光的传输频率极高，因此光纤通信系统的传输宽带远大于目前各种传输媒体宽带 光缆传输信号的原理 在发送端首先要把传送的信息(如话音)变成电信号，然后调制到激光器发出的激光束上，使光的强度随电信号的幅度(频率)变化而变化，并通过光纤发送出去；在接收端，检测器收到光信号后把它变换成电信号，经解调后恢复原信息 微波通信的优缺点 缺点：微波传播距离很短，一般在50Km左右，微波被地表吸收后，传输损耗很大。 优点：微波即可传输模拟信号也可以传输数字信号。微波的频率很高，可以同时传输大量信息。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]},{"title":"计算机网络概述","slug":"01，计算机网络概述","date":"2013-12-31T16:00:00.000Z","updated":"2017-08-05T04:01:38.000Z","comments":true,"path":"2014/01/01/01，计算机网络概述/","link":"","permalink":"http://blog.vnicers.com/2014/01/01/01，计算机网络概述/","excerpt":"","text":"什么是计算机网络？ 它有什么功能？ 计算机网络就是通过线路互连起来，自治的计算机集合，确切的讲就是将分布在不同的地理位置的具有独立工作能力的计算机，终端，及其附属设备用通信设备和线路连接起来，并配置网络软件以实现计算机网络资源共享的系统 计算机网络具有的功能： 数据交换和通信 资源共享 提高系统的可靠性和可用性 均衡负荷，相互协作 分布式网络处理 提高系统的性价比，易于扩充和维护 计算机网络发展分为几个阶段，每个阶段各有什么特点？ 面向终端的计算机网络（20世纪50年代） 特点：由一台中心计算机和若干终端组成 ，通信线路和中心计算机之间有一个前端处理器或者通信控制器实现数据处理和通信控制分工 计算机-计算机网络（20世纪60年代） 特点：利用通信线路将若干台机器互联起来的系，实现了计算机和计算机之间的通信，以通信子网为中心多主机多终端 标准化网络（20世纪70-80年代） 特点：局域网广泛发展起来，ISO组织颁布“OSI参考模型” 计算机网络步入成熟阶段 高速互联网络-第四代计算机网络（20世纪90年代） 特点：随着计算机网络的高速发展。多个国家制定了本国的NII,极大的推动了计算机网络的发展 计算机网络由那几部分组成？各个部分的功能？ 通信子网（通信控制机（路由器和交换机），通信线路，通信设备） 一方面作为连接资源子网的主机和终端的接口将主机和终端接入网内，另一方面作为通信子网中的分组存储转发节点，完成分组的接收，校验，存储，转发等功能 资源子网（主机系统，终端，网络操作系统，网络数据库，应用系统）实现全网的面相应用的数据处理和网络资源共享 一系列协议 为了在主机和主机之间或者和各节点之间的通信服务，是通信双方事先约定好的和必须遵守的规则 计算机网络从哪些角度分类？可以分为哪些类型？ 按照网络的地理范围分类 个域网 PAN 局域网 LAN 特点：为短距离通信设计，有限的地理范围（几公里内） 城域网 MAN 特点：一种大型的LAN,覆盖范围介于局域网和广域网，分布在一个较小的行政辖区内 广域网 WAN 特点：多个城域网组成，跨地区，跨行业，跨国 按照网络拓扑结构分类 星型结构 特点：集中控制型网络，中心节点复杂，各个节点通信负担都很小 总线结构 特点：广播式传输结构，网络设备少，安装和使用方便 环型结构 特点：环路中各节点地位相同，一个节点发出的信息必须穿越环中所有的环路接口 树形结构 特点：星型拓扑的发展和补充，为分层结构，具有根节点和各分支节点，适用于分支管理和控制的系统 按照传输技术分类 广播式网络 点对点网络 按照网络应用领域分类 专用网 公用网 通信介质分类 有线网络 无线网络 按网络组件关系分类 对等网络 基于服务器的网络","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.vnicers.com/tags/网络/"}]}]}